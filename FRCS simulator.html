<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Ophthalmology Q&A Simulator for FRCOphth/FRCS Exam Preparation with advanced spaced repetition learning and personalized study focus features">
    <meta name="author" content="Dr. Mahmoud Sami">
    <title>Ophthalmology Q&A Simulator - FRCOphth/FRCS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <meta name="theme-color" content="#3f51b5">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FRCS Simulator">
    <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAF1UlEQVR4nO2dT2gcVRzHf29mkjbpVmqaFDSKVg+CvQiKNz1okUChuQgiePAQvCjWgwh68KDiH8SDInqpiIfi0YNKEUQRsR4UNGga9GKLf7FpY7rJdnf+vFnfZGYyM9nsvDfvzZvd3w8Mzb7ZTd77/b7fed/M7JtZIAiCIAiCIAiCIAiCIAiCIAiCIAiCKA7k+whMz8xOG2a67vDwsJGQpqmgqlo7lZ5Ppdp7SRAEQRAEQRAEQRCEHlJ9WQ/MzMz0NJ0f/JmHbA2aMhMECKDzFoKZrgIzRqP1PJNOE9KRvhOD+XVmcT+H/Obm4CrE6wAAAGAaaTDTaUil0mnJfA4sTwKOxxGGAcnUvXWkVH57b25upa+aLOmrAEUkXsFXrytSCyCTgKgQAbSFJk4K37Yo/0jTyBD3KdpOwDYmkzWovJFJiAu5nYATExPT6XR6Pp1O98SjOOWmaXrOMCNdJ1YKUEQqJFBhKgUsAQCk0yk4cWIMysNHYGb8LJTLo3DixNjRYnTyfkllwjY295CQANLpFNydn4Qnzu2CV2z6rqvWjvTxj17Bxa/vR37+yROjcP7cCJyaOArnXjgNS7/9AZPjIW/j77SFJw+WfJJ4Av+5VrOGV/Ng8+P3a3D7tz/h0lffOb8dPTwEM8+U4flzZVhZ8f7SjHZv/lG7nXu9Mbo+19cAFxYuwc8/fdDz/ZPPvoTrP93seP7S4rcwNnoIZmfGjfoCT5w9BvduW13b/fpqFd78WM/HBBz7eF9bLhNLAM3mBty4UQmsQ3X1AGr1A3jt9XP7BkJO5T4kYPdjlcMlWFk1ux7a2tmDm7cfu+u6EJRR5Lp6m+7SxMUILUC9Xodq9V7kfp2GMuYHQ6VW24G5F0/DufPPoATfWXlR37YiVuPjRt9jgDBuVeqWGI0+LIpcfX3B4cWXg5KHdq+39dGACDYT8ZOQ40+wBCgCYrH1e0SCdp/kRYC+LgODKFsNcWgYlF5ELPsFDe9RiU2AvKJhvwyLNxbGc6ztjrFnXZzPEeYa9vS5W0ydQ8D4+HgsHcmyeXQbfOaK67Uq8mzUtj+yd2kYhiuHAHJvGYLw7Jf6GsBNnLvmfvoMw7sMDAqG4bvGj+I+pjkEWHvfogmAu1tLpZJrAwePE4BfA3c28fNNABwQz+uCAH67cDw86xKgn72Iu1BVTc8aPBYBULYK8NiLuBtV1fbkbukgvbKvBRBFAEYjKuU1AdW1v16CugcO0c/eKL1WVbXtaaBbuwS1BuCawzBMz2uwzLmtAaLsn7j2v2/38Cil49HFLypT3xdLxgIYhmF7EwSVs96/u7trG/r8Qv3WViOCUUHbR0GxCwBg9xfDsG5pO6m3t1vHWrrn9Nk1GOL9tLt9v75a6N4/3I8GWQyLuUuAG0Q7aP4JAcD+oqiNKLM9yxDgbWPO61n7tNZ4s+nKPb4GIM+yI4BbUBURAGCfSxZzS7oJMCwVdRaAUwDniJvv6AywbwVAP/j22FzGdQHYoYqVoFtAlwBFneVVBSgcohYI57jvFQDZf1LnKOBFZdN9CEABxEPr5jjeFN0WgH5QFeCSbNQCeI38busPJ3Ie1P0SAHt179+mYOA1wnv9djAOv0dVLXBJkL9XBdkUXZOEIAjOQeK+RkEgvwUgcygAOTxswX594P5Gj/H1xf9BF3l4kwV9gwMRQFvIAcpvJMgKvggYx+0EbMO3qswzQ79PJYKfQwBeI9bP4JFcb1lZq2bBs6y7/u41Yzgd7U5w1wPGYJllJ8j/RZJWDvGmzMf4//8j2AIok8Dk0Rf7xwDKBCBZg1LtpVsOoLMQvBWL5UWRYc8ABEEQBEEQBEEQBEEQBEEQBEEQBEEQA+NfLcwBj7CrGhAAAAAASUVORK5CYII=">
    <style>
        :root {
            --primary: #3f51b5;
            --primary-dark: #303f9f;
            --primary-light: #c5cae9;
            --accent: #ff4081;
            --text-primary: #212121;
            --text-secondary: #757575;
            --background: #f5f5f5;
            --card-bg: #ffffff;
            --error: #f44336;
            --success: #4caf50;
            --font-primary: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            font-family: var(--font-primary);
            margin: 0;
            padding: 0;
            background-color: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        h1 {
            margin: 0;
            font-size: 28px;
        }
        
        .subtitle {
            font-size: 16px;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
        }
        
        .btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background-color: white;
            color: var(--primary);
            border: 1px solid var(--primary);
        }
        
        .btn-secondary:hover {
            background-color: var(--primary-light);
            color: var(--primary-dark);
        }
        
        .btn-accent {
            background-color: var(--accent);
        }
        
        .btn-accent:hover {
            background-color: #e91e63;
        }
        
        .option-btn {
            display: block;
            width: 100%;
            text-align: left;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .option-btn:hover {
            background-color: var(--primary-light);
        }
        
        .option-btn.selected {
            background-color: var(--primary);
            color: white;
        }
        
        .option-btn.correct {
            background-color: var(--success);
            color: white;
        }
        
        .option-btn.incorrect {
            background-color: var(--error);
            color: white;
        }
        
        .explanation {
            background-color: #f8f9fa;
            border-left: 4px solid var(--primary);
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }
        
        .hidden {
            display: none;
        }
        
        .score-display {
            font-size: 24px;
            text-align: center;
            margin: 20px 0;
        }
        
        .category-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary);
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
        
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        
        .tab-btn {
            padding: 12px 20px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
        }
        
        .tab-btn.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }
        
        .tab-content {
            padding: 20px 0;
        }
        
        .tab-panel {
            will-change: opacity;
            transition: opacity 0.3s ease;
            opacity: 0;
            display: none;
        }
        
        .tab-panel.active {
            opacity: 1;
            display: block;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        select, input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: var(--primary-light);
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
        }
        
        .loading:after {
            content: " ";
            display: block;
            width: 64px;
            height: 64px;
            margin: 8px;
            border-radius: 50%;
            border: 6px solid var(--primary);
            border-color: var(--primary) transparent var(--primary) transparent;
            animation: loading 1.2s linear infinite;
        }
        
        @keyframes loading {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .timer {
            font-size: 24px;
            text-align: right;
            margin-bottom: 10px;
        }
        
        .question-navigation {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 20px 0;
        }
        
        .question-nav-btn {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            background-color: white;
        }
        
        .question-nav-btn.current {
            border: 2px solid var(--primary);
        }
        
        .question-nav-btn.answered {
            background-color: var(--primary-light);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .card {
                padding: 15px;
            }
            
            .btn {
                width: 100%;
                margin-bottom: 10px;
            }
            
            .tab-btn {
                padding: 10px;
                font-size: 14px;
            }
            
            .sources-container {
                grid-template-columns: 1fr;
            }
            
            .tab-buttons {
                flex-wrap: wrap;
            }
            
            .tab-btn {
                flex: 1 1 auto;
                min-width: 120px;
            }
            
            .difficulty-options {
                flex-wrap: wrap;
            }
        }
        
        .source-option {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .source-option input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .input-group {
            margin-bottom: 10px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: normal;
        }
        
        .info-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background-color: var(--primary);
            color: white;
            text-align: center;
            line-height: 18px;
            border-radius: 50%;
            font-size: 12px;
            margin-left: 5px;
            cursor: help;
        }
        
        .info-tooltip {
            position: relative;
            display: inline-block;
        }
        
        .info-tooltip .tooltip-text {
            visibility: hidden;
            width: 300px;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
            font-weight: normal;
        }
        
        .info-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Additional styles for Anki viewer */
        .anki-card {
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .anki-question {
            font-weight: bold;
            color: var(--primary);
            font-size: 18px;
            margin-bottom: 10px;
        }
        .anki-answer {
            padding-left: 15px;
            border-left: 3px solid #e0e0e0;
        }
        #anki-deck-title {
            color: var(--text-primary);
            text-align: center;
            margin: 20px 0;
        }
        .copyright {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
            font-style: italic;
        }
        
        .difficulty-selector {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .difficulty-btn {
            flex: 1;
            text-align: center;
            padding: 8px 0;
            border: 1px solid var(--primary);
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .difficulty-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .difficulty-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .difficulty-btn.active {
            background: var(--primary);
            color: white;
        }
        
        .clinical-image {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .reference-link {
            display: block;
            margin-top: 10px;
            color: var(--primary);
            text-decoration: none;
            font-size: 14px;
        }
        
        .reference-link:hover {
            text-decoration: underline;
        }
        
        .source-option {
            margin-bottom: 10px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 350px;
            transition: all 0.3s ease;
            animation: slideIn 0.5s forwards;
            border-left: 4px solid var(--primary);
        }
        
        .notification.success {
            border-left-color: var(--success);
            background-color: #f0fff0;
        }
        
        .notification.error {
            border-left-color: var(--error);
            background-color: #fff0f0;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Add Anki import section styles */
        .import-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        
        .import-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .import-form input {
            flex: 1;
        }
        
        /* Home page improvements */
        .welcome-banner {
            background-color: var(--primary-light);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .welcome-banner h2 {
            color: var(--primary-dark);
            margin-top: 0;
        }
        
        .sources-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .sources-card, .practice-card {
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .sources-card h2, .practice-card h2 {
            margin-top: 0;
            color: var(--primary);
            border-bottom: 2px solid var(--primary-light);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .difficulty-selector {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .difficulty-label {
            font-weight: 500;
            margin-bottom: 10px;
            display: block;
        }
        
        .difficulty-options {
            display: flex;
            gap: 10px;
        }
        
        .question-preview {
            background-color: var(--primary-light);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .question-preview h3 {
            margin-top: 0;
            color: var(--primary-dark);
        }
        
        .question-preview p {
            margin-bottom: 0;
        }
        
        .feature-badge {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
            vertical-align: middle;
        }

        .text-center {
            text-align: center;
        }

        .button-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .question-category {
            font-weight: 500;
            color: var(--primary);
            margin-bottom: 10px;
        }

        /* Dark mode, high contrast, and font size settings */
        .dark-mode {
            --background: #121212;
            --card-bg: #1e1e1e;
            --text-primary: #e0e0e0;
            --text-secondary: #9e9e9e;
            --primary-light: #3f4a7a;
        }

        .dark-mode .card, 
        .dark-mode .sources-card, 
        .dark-mode .practice-card {
            background-color: var(--card-bg);
            color: var(--text-primary);
        }

        .dark-mode .option-btn {
            background-color: #2a2a2a;
            border-color: #444;
            color: var(--text-primary);
        }

        .dark-mode .option-btn:hover {
            background-color: #3a3a3a;
        }

        .dark-mode .welcome-banner {
            background-color: #2a3256;
        }

        .dark-mode .welcome-banner h2 {
            color: #c5cae9;
        }

        .high-contrast {
            --primary: #0066cc;
            --primary-dark: #004999;
            --primary-light: #4d94ff;
            --accent: #cc0066;
            --error: #cc0000;
            --success: #00cc66;
        }

        .high-contrast .btn, 
        .high-contrast .option-btn.selected {
            border: 2px solid #000;
        }

        .high-contrast.dark-mode .btn, 
        .high-contrast.dark-mode .option-btn.selected {
            border: 2px solid #fff;
        }

        .font-small {
            font-size: 14px;
        }

        .font-small h1 {
            font-size: 24px;
        }

        .font-small h2 {
            font-size: 20px;
        }

        .font-small h3 {
            font-size: 16px;
        }

        .font-medium {
            font-size: 16px;
        }

        .font-large {
            font-size: 18px;
        }

        .font-large h1 {
            font-size: 32px;
        }

        .font-large h2 {
            font-size: 28px;
        }

        .font-large h3 {
            font-size: 22px;
        }

        .option-group {
            margin-bottom: 15px;
        }

        .option-group label {
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .option-group select {
            padding: 8px;
            width: 200px;
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .hint {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: 5px;
            margin-bottom: 15px;
        }

        fieldset {
            border: none;
            padding: 0;
            margin: 0 0 20px 0;
        }

        legend {
            font-weight: 600;
            font-size: 1.1em;
            color: var(--primary);
            margin-bottom: 10px;
            display: block;
            width: 100%;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--primary-light);
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-start;
        }

        .checkbox-wrapper {
            margin-bottom: 10px;
        }

        .checkbox-wrapper label {
            display: inline;
            margin-left: 5px;
        }

        .file-input-label {
            display: inline-block;
            padding: 8px 12px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        /* Improved data display */
        dl.result-details {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin: 20px 0;
        }

        dl.result-details dt {
            font-weight: bold;
            color: var(--primary);
        }

        dl.result-details dd {
            margin: 0;
        }

        /* Table improvements */
        .table-responsive {
            overflow-x: auto;
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        table caption {
            text-align: left;
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: rgba(0,0,0,0.02);
        }

        /* Focus states for accessibility */
        a:focus,
        button:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .dark-mode a:focus,
        .dark-mode button:focus,
        .dark-mode input:focus,
        .dark-mode select:focus,
        .dark-mode textarea:focus {
            outline-color: var(--primary-light);
        }

        /* Skip to content link for keyboard navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary);
            color: white;
            padding: 8px;
            z-index: 100;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Dark mode table adjustments */
        .dark-mode th {
            background-color: var(--primary-dark);
            color: #fff;
        }

        .dark-mode tr:nth-child(even) {
            background-color: rgba(255,255,255,0.05);
        }

        .dark-mode .hint {
            color: #aaa;
        }

        .dark-mode .file-input-label {
            background-color: #2a2a2a;
            border-color: #444;
        }

        /* Performance optimizations */
        img {
            max-width: 100%;
            height: auto;
        }

        /* Optimize for print */
        @media print {
            .tab-btn, .btn:not(.active), 
            button:not(.tab-btn.active), 
            .import-section, .welcome-banner {
                display: none !important;
            }
            
            .tab-panel:not(.active) {
                display: none !important;
            }
            
            .container {
                width: 100%;
                margin: 0;
                padding: 0;
            }
            
            body {
                background-color: white;
                color: black;
            }
            
            .card, .sources-card, .practice-card {
                box-shadow: none;
                border: 1px solid #ddd;
                margin-bottom: 10px;
            }
        }

        /* Loading button styles */
        .btn.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }

        .btn.loading::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn-secondary.loading::after {
            border: 2px solid rgba(63, 81, 181, 0.3);
            border-top-color: var(--primary);
        }

        /* Update slideIn animation to use transform */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .priority-categories {
            background-color: var(--primary-light);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .priority-categories h3 {
            color: var(--primary-dark);
            margin-top: 0;
        }
        
        .priority-categories p {
            margin-bottom: 15px;
        }
        
        .priority-categories .checkbox-wrapper {
            display: inline-block;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        
        .dark-mode .priority-categories {
            background-color: var(--primary-dark);
        }
        
        .dark-mode .priority-categories h3 {
            color: #fff;
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <header>
        <h1>Ophthalmology Q&A Simulator</h1>
        <div class="subtitle">FRCOphth/FRCS Exam Preparation</div>
        <div class="copyright">Designed by Dr. Mahmoud Sami © 2025</div>
    </header>
    
    <main id="main-content" class="container" tabindex="-1">
        <div class="tab-container">
            <div class="tab-buttons" role="tablist">
                <button class="tab-btn active" id="tab-practice" data-tab="practice" role="tab" aria-selected="true" aria-controls="practice">Practice Questions</button>
                <button class="tab-btn" id="tab-exam" data-tab="exam" role="tab" aria-selected="false" aria-controls="exam">Mock Exam</button>
                <button class="tab-btn" id="tab-stats" data-tab="stats" role="tab" aria-selected="false" aria-controls="stats">Performance Stats</button>
                <button class="tab-btn" id="tab-review" data-tab="review" role="tab" aria-selected="false" aria-controls="review">Review Mistakes</button>
                <button class="tab-btn" id="tab-settings" data-tab="settings" role="tab" aria-selected="false" aria-controls="settings">Settings</button>
                <button class="tab-btn" id="tab-help" data-tab="help" role="tab" aria-selected="false" aria-controls="help">Help</button>
            </div>
        
            <div class="tab-content">
                <!-- Practice Questions Tab -->
                <div id="practice" class="tab-panel active">
                    <div class="welcome-banner" role="banner">
                        <h2>Welcome to Ophthalmology Q&A Simulator</h2>
                        <p>Prepare for your FRCOphth/FRCS exams with our comprehensive question bank. Practice with questions from various sources, test your knowledge with mock exams, and track your progress.</p>
                    </div>
                    
                    <div class="sources-container">
                        <section class="sources-card">
                            <h2>Question Sources</h2>
                            <div class="form-group" id="sourceSelector" role="group" aria-label="Available question sources">
                                <!-- Sources will be populated here -->
                            </div>
                        </section>
                        
                        <section class="sources-card">
                            <h2>API Keys <span class="feature-badge">Optional</span></h2>
                            <p>Add your API keys to access premium question banks.</p>
                            <div class="form-group">
                                <div id="apiKeyInputs">
                                    <!-- API key inputs will be populated here -->
                                </div>
                            </div>
                            
                            <div class="import-section">
                                <h3>Import Questions from Anki Deck</h3>
                                <p>Import questions and answers from an Anki deck to enhance your local database.</p>
                                <div class="import-form">
                                    <label for="ankiDeckUrl" class="sr-only">Anki Deck URL</label>
                                    <input type="text" id="ankiDeckUrl" placeholder="Enter Anki deck URL" value="https://drive.google.com/file/d/1vx2BK---afx020847jDBvbcsd0k87qfH/view">
                                    <button id="importAnkiBtn" class="btn">Import</button>
                                </div>
                            </div>
                        </section>
                    </div>
                    
                    <section class="practice-card">
                        <h2>Practice Questions</h2>
                        
                        <div class="difficulty-selector">
                            <label class="difficulty-label" id="difficulty-group-label">Difficulty Level:</label>
                            <div class="difficulty-options" role="group" aria-labelledby="difficulty-group-label">
                                <button class="btn btn-secondary difficulty-btn active" data-difficulty="Easy">Easy</button>
                                <button class="btn btn-secondary difficulty-btn" data-difficulty="Medium">Medium</button>
                                <button class="btn btn-secondary difficulty-btn" data-difficulty="Hard">Hard</button>
                                <button class="btn btn-secondary difficulty-btn" data-difficulty="All">All Levels</button>
                            </div>
                        </div>
                        
                        <div class="category-selector">
                            <h3 id="category-group-label">Select Category:</h3>
                            <div id="categoryButtons" role="group" aria-labelledby="category-group-label">
                                <!-- Category buttons will be populated here -->
                            </div>
                        </div>
                        
                        <div class="priority-categories">
                            <h3>Priority Focus Areas <span class="feature-badge">New</span></h3>
                            <p>Select categories to prioritize in your practice sessions. These areas will appear more frequently.</p>
                            <div id="priorityCategoriesSelector" class="form-group">
                                <!-- Priority categories checkboxes will be populated here -->
                            </div>
                            <button id="savePriorityBtn" class="btn btn-secondary">Save Priorities</button>
                        </div>
                        
                        <div class="text-center" style="margin-top: 20px;">
                            <button id="randomQuestionBtn" class="btn btn-accent">Get Random Question</button>
                        </div>
                    </section>
                    
                    <!-- Question Card -->
                    <section id="questionCard" class="card hidden" aria-live="polite">
                        <header>
                            <div id="questionCategory" class="question-category">Category: General Ophthalmology</div>
                            <h3 id="questionText" class="question-text">Question text will appear here.</h3>
                        </header>
                        <div id="optionsContainer" class="options-container" role="radiogroup" aria-labelledby="questionText">
                            <!-- Options will be dynamically added here -->
                        </div>
                        <div class="button-container">
                            <button id="submitAnswerBtn" class="btn" disabled>Submit Answer</button>
                            <button id="nextQuestionBtn" class="btn hidden">Next Question</button>
                        </div>
                        <footer id="explanation" class="explanation hidden">
                            <!-- Explanation will be added here after answer submission -->
                        </footer>
                    </section>
                </div>
                
                <!-- Mock Exam Tab -->
                <div id="exam" class="tab-panel">
                    <section class="card" id="examSetup">
                        <h2>Mock Exam Setup</h2>
                        <form onsubmit="return false;">
                            <div class="form-group">
                                <label for="examLength">Number of Questions:</label>
                                <select id="examLength">
                                    <option value="10">10 Questions (~15 min)</option>
                                    <option value="25">25 Questions (~40 min)</option>
                                    <option value="50">50 Questions (~1.5 hours)</option>
                                    <option value="100">100 Questions (~3 hours)</option>
                                </select>
                            </div>
                            <button type="button" class="btn" id="startExamBtn">Start Mock Exam</button>
                        </form>
                    </section>
                    
                    <section id="examContent" class="hidden">
                        <article class="card">
                            <header>
                                <div class="timer" id="examTimer" aria-live="polite">00:00:00</div>
                                <div class="progress-container">
                                    <div>Progress: <span id="examProgress">0/0</span></div>
                                    <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                                        <div class="progress-fill" id="examProgressBar" style="width: 0%"></div>
                                    </div>
                                </div>
                                
                                <nav class="question-navigation" id="questionNavigation" aria-label="Exam question navigation">
                                    <!-- Question navigation buttons will go here -->
                                </nav>
                            </header>
                            
                            <div id="examQuestionCategory" class="question-category">Category: </div>
                            <h3 id="examQuestionText" class="question-text"></h3>
                            <div id="examOptionsContainer" class="options-container" role="radiogroup" aria-labelledby="examQuestionText">
                                <!-- Options will be populated here -->
                            </div>
                            
                            <div class="button-container">
                                <button type="button" class="btn" id="prevExamQuestionBtn">Previous</button>
                                <button type="button" class="btn" id="nextExamQuestionBtn">Next</button>
                                <button type="button" class="btn btn-accent" id="finishExamBtn">Finish Exam</button>
                            </div>
                        </article>
                    </section>
                    
                    <section id="examResults" class="card hidden">
                        <h2>Exam Results</h2>
                        <div class="score-display" aria-live="polite">
                            <span id="examScore">0</span>/<span id="examTotal">0</span>
                            (<span id="examPercentage">0%</span>)
                        </div>
                        <dl class="result-details">
                            <dt>Time spent:</dt>
                            <dd id="examTimeSpent">0:00:00</dd>
                            <dt>Correct answers:</dt>
                            <dd id="examCorrect">0</dd>
                            <dt>Incorrect answers:</dt>
                            <dd id="examIncorrect">0</dd>
                        </dl>
                        <div class="button-container">
                            <button type="button" class="btn" id="reviewExamBtn">Review Answers</button>
                            <button type="button" class="btn" id="newExamBtn">New Exam</button>
                        </div>
                        <div id="incorrectAnswersContainer" aria-live="polite">
                            <!-- Incorrect answers will be populated here -->
                        </div>
                    </section>
                </div>
                
                <!-- Stats Tab -->
                <section id="stats" class="tab-panel" role="tabpanel" aria-labelledby="tab-stats">
                    <article class="card">
                        <h2>Your Performance Statistics</h2>
                        <div class="stat-grid">
                            <div class="stat-card">
                                <div class="stat-number" id="totalQuestions">0</div>
                                <div>Questions Attempted</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="correctAnswers">0</div>
                                <div>Correct Answers</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="accuracyRate">0%</div>
                                <div>Accuracy Rate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="examsCompleted">0</div>
                                <div>Exams Completed</div>
                            </div>
                        </div>
                        
                        <h3>Performance by Category</h3>
                        <div class="table-responsive">
                            <table id="categoryStats">
                                <caption>Category-wise performance statistics</caption>
                                <thead>
                                    <tr>
                                        <th scope="col">Category</th>
                                        <th scope="col">Questions</th>
                                        <th scope="col">Correct</th>
                                        <th scope="col">Accuracy</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Category stats will be populated here -->
                                </tbody>
                            </table>
                        </div>
                    </article>
                </section>
                
                <!-- Review Mistakes Tab -->
                <section id="review" class="tab-panel" role="tabpanel" aria-labelledby="tab-review">
                    <article class="card">
                        <h2>Review Missed Questions</h2>
                        <form class="form-group" onsubmit="return false;">
                            <label for="reviewCategory">Filter by Category:</label>
                            <select id="reviewCategory">
                                <option value="all">All Categories</option>
                                <!-- Categories will be populated here -->
                            </select>
                        </form>
                        <div id="missedQuestionsContainer">
                            <!-- Missed questions will be populated here -->
                        </div>
                    </article>
                </section>
                
                <!-- Settings Tab -->
                <div id="settings" class="tab-panel">
                    <section class="card">
                        <h2>Application Settings</h2>
                        
                        <form class="settings-form" id="settingsForm" onsubmit="return false;">
                            <fieldset class="form-group">
                                <legend>Appearance</legend>
                                <div class="option-group">
                                    <div class="checkbox-wrapper">
                                        <input type="checkbox" id="darkModeToggle" aria-describedby="darkModeHint">
                                        <label for="darkModeToggle">Enable Dark Mode</label>
                                        <p id="darkModeHint" class="hint">Dark background with light text for reduced eye strain in low light environments.</p>
                                    </div>
                                    
                                    <div class="checkbox-wrapper">
                                        <input type="checkbox" id="highContrastToggle" aria-describedby="contrastHint">
                                        <label for="highContrastToggle">High Contrast Mode</label>
                                        <p id="contrastHint" class="hint">Increases contrast between elements for better visibility.</p>
                                    </div>
                                </div>
                            </fieldset>
                            
                            <fieldset class="form-group">
                                <legend>Content Display</legend>
                                <div class="option-group">
                                    <label for="fontSizeSelector">Font Size:</label>
                                    <select id="fontSizeSelector" aria-describedby="fontSizeHint">
                                        <option value="small">Small</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="large">Large</option>
                                    </select>
                                    <p id="fontSizeHint" class="hint">Adjust text size for comfortable reading.</p>
                                </div>
                            </fieldset>
                        </form>
                        
                        <div class="form-group">
                            <h3>Data Management</h3>
                            <div class="button-group" role="group" aria-label="Data management options">
                                <button type="button" id="exportDataBtn" class="btn" aria-describedby="exportHint">Export Your Data</button>
                                <p id="exportHint" class="hint">Download all your questions and statistics as a JSON file.</p>
                                
                                <button type="button" id="resetStatsBtn" class="btn btn-secondary" aria-describedby="resetHint">Reset Statistics</button>
                                <p id="resetHint" class="hint">Clear all your performance statistics while keeping your questions.</p>
                                
                                <button type="button" id="clearLocalDbBtn" class="btn btn-secondary" aria-describedby="clearHint">Clear Local Database</button>
                                <p id="clearHint" class="hint">Remove all imported questions from your local database.</p>
                            </div>
                        </div>
                    </section>
                    
                    <section class="card">
                        <h2>Import Questions</h2>
                        <p>Expand your question bank by importing from different sources.</p>
                        
                        <div class="form-group">
                            <h3>Import from Anki Deck</h3>
                            <form class="import-form" onsubmit="return false;">
                                <label for="ankiDeckUrlSettings" class="sr-only">Anki Deck URL</label>
                                <input type="text" id="ankiDeckUrlSettings" placeholder="Enter Anki deck URL" value="https://drive.google.com/file/d/1vx2BK---afx020847jDBvbcsd0k87qfH/view">
                                <button type="button" id="importAnkiBtnSettings" class="btn">Import</button>
                            </form>
                            <p class="hint">Supports Google Drive links to Anki decks in JSON format.</p>
                        </div>
                        
                        <div class="form-group">
                            <h3>Import from CSV</h3>
                            <p>Upload a CSV file with questions, options, and answers.</p>
                            <form class="csv-import-form" onsubmit="return false;">
                                <label for="csvFileInput" class="file-input-label">Choose CSV File</label>
                                <input type="file" id="csvFileInput" accept=".csv" aria-describedby="csvHint">
                                <button type="button" id="uploadCsvBtn" class="btn">Upload</button>
                            </form>
                            <p id="csvHint" class="hint">CSV format: Question, Option1, Option2, Option3, Option4, CorrectAnswer, Explanation, Category</p>
                        </div>
                    </section>
                </div>
                
                <!-- Help Tab -->
                <section id="help" class="tab-panel" role="tabpanel" aria-labelledby="tab-help">
                    <article class="card">
                        <h2>How to Use This Simulator</h2>
                        <h3>Overview</h3>
                        <p>This simulator is designed to help ophthalmology trainees prepare for the FRCOphth/FRCS examinations. It features a comprehensive question bank, mock exams, and performance tracking.</p>
                        
                        <!-- Rest of the help content -->
                    </article>
                </section>
            </div>
        </div>
    </main>
    
    <footer>
        <p class="copyright">&copy; 2025 Dr. Mahmoud Sami. All rights reserved.</p>
    </footer>

    <script>
        // Add this right before the existing tab navigation code
        // Initialize tabButtons and tabPanels references properly
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabPanels = document.querySelectorAll('.tab-panel');

        // Define the simulator object to store all functionality
        const simulator = {
            questionDatabase: [],
            categories: ['Anterior Segment', 'Posterior Segment', 'Glaucoma', 'Neuro-ophthalmology', 
                         'Pediatric Ophthalmology', 'Oculoplastics', 'General Ophthalmology'],
            currentQuestion: null,
            selectedAnswer: null,
            examQuestions: [],
            currentExamQuestionIndex: 0,
            examStartTime: null,
            examEndTime: null,
            examAnswers: [],
            stats: {
                totalQuestions: 0,
                correctAnswers: 0,
                examsCompleted: 0
            },
            categoryStats: {},
            apiKeys: {},
            activeExternalSources: {},
            priorityCategories: [], // New property for priority categories

            // Get a random question based on category and difficulty
            getRandomQuestion: function(category, difficulty) {
                const filteredQuestions = this.questionDatabase.filter(q => {
                    if (category && category !== 'All' && q.category !== category) return false;
                    if (difficulty && difficulty !== 'All' && q.difficulty !== difficulty) return false;
                    return true;
                });
                
                if (filteredQuestions.length === 0) {
                    return null;
                }
                
                return filteredQuestions[Math.floor(Math.random() * filteredQuestions.length)];
            },
            
            // Mark a question as answered
            markQuestionAsAnswered: function(questionId, selectedOption, isCorrect) {
                // Find question in database
                const questionIndex = this.questionDatabase.findIndex(q => q.id === questionId);
                if (questionIndex !== -1) {
                    const question = this.questionDatabase[questionIndex];
                    
                    // Update question stats
                    if (!question.stats) {
                        question.stats = {
                            attempts: 0,
                            correct: 0,
                            lastAttemptTime: Date.now()
                        };
                    } else {
                        question.stats.lastAttemptTime = Date.now();
                    }
                    
                    question.stats.attempts++;
                    if (isCorrect) {
                        question.stats.correct++;
                    }
                    
                    // Update global stats
                    this.stats.totalQuestions++;
                    if (isCorrect) {
                        this.stats.correctAnswers++;
                    }
                    
                    // Update category stats
                    if (!this.categoryStats[question.category]) {
                        this.categoryStats[question.category] = {
                            questions: 0,
                            correct: 0
                        };
                    }
                    
                    this.categoryStats[question.category].questions++;
                    if (isCorrect) {
                        this.categoryStats[question.category].correct++;
                    }
                    
                    // Record activity
                    if (typeof this.recordActivity === 'function') {
                        this.recordActivity('question_answered', {
                            questionId: questionId,
                            category: question.category,
                            difficulty: question.difficulty,
                            isCorrect: isCorrect
                        });
                    }
                    
                    // Save stats to localStorage
                    this.saveStats();
                }
            },
            
            // Generate mock exam questions
            generateExam: function(questionCount) {
                const allQuestions = this.questionDatabase.slice();
                if (allQuestions.length < questionCount) {
                    // If not enough questions, use all available and show warning
                    this.examQuestions = allQuestions.map(q => ({ ...q }));
                    return false;
                }
                
                // Shuffle array
                for (let i = allQuestions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allQuestions[i], allQuestions[j]] = [allQuestions[j], allQuestions[i]];
                }
                
                // Take first 'questionCount' questions
                this.examQuestions = allQuestions.slice(0, questionCount).map(q => ({ ...q }));
                this.examAnswers = new Array(this.examQuestions.length).fill(null);
                this.currentExamQuestionIndex = 0;
                this.examStartTime = new Date();
                
                return true;
            },
            
            // Calculate exam results
            calculateExamResults: function() {
                let correctCount = 0;
                
                for (let i = 0; i < this.examQuestions.length; i++) {
                    const question = this.examQuestions[i];
                    const selectedAnswer = this.examAnswers[i];
                    
                    if (selectedAnswer !== null && question.correctAnswer === selectedAnswer) {
                        correctCount++;
                    }
                    
                    // Update stats for each question
                    this.markQuestionAsAnswered(question.id, selectedAnswer, 
                        question.correctAnswer === selectedAnswer);
                }
                
                // Update exam stats
                this.stats.examsCompleted++;
                this.examEndTime = new Date();
                this.saveStats();
                
                return {
                    correct: correctCount,
                    total: this.examQuestions.length,
                    percentage: Math.round((correctCount / this.examQuestions.length) * 100),
                    timeSpent: this.formatTimeSpent(this.examStartTime, this.examEndTime)
                };
            },
            
            // Format time spent for display
            formatTimeSpent: function(startTime, endTime) {
                const seconds = Math.floor((endTime - startTime) / 1000);
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;
                
                return `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            },
            
            // Save stats to localStorage
            saveStats: function() {
                localStorage.setItem('ophthQA_stats', JSON.stringify(this.stats));
                localStorage.setItem('ophthQA_categoryStats', JSON.stringify(this.categoryStats));
                localStorage.setItem('ophthQA_database', JSON.stringify(this.questionDatabase));
                localStorage.setItem('ophthQA_priorityCategories', JSON.stringify(this.priorityCategories));
            },
            
            // Load stats from localStorage
            loadStats: function() {
                const savedStats = localStorage.getItem('ophthQA_stats');
                const savedCategoryStats = localStorage.getItem('ophthQA_categoryStats');
                const savedDatabase = localStorage.getItem('ophthQA_database');
                const savedApiKeys = localStorage.getItem('ophthQA_apiKeys');
                const savedExternalSources = localStorage.getItem('ophthQA_activeSources');
                const savedPriorityCategories = localStorage.getItem('ophthQA_priorityCategories');
                
                if (savedStats) {
                    this.stats = JSON.parse(savedStats);
                }
                
                if (savedCategoryStats) {
                    this.categoryStats = JSON.parse(savedCategoryStats);
                }
                
                if (savedDatabase) {
                    this.questionDatabase = JSON.parse(savedDatabase);
                }
                
                if (savedApiKeys) {
                    this.apiKeys = JSON.parse(savedApiKeys);
                }
                
                if (savedExternalSources) {
                    this.activeExternalSources = JSON.parse(savedExternalSources);
                    
                    // Fix activeExternalSources if it's an array instead of an object
                    if (Array.isArray(this.activeExternalSources)) {
                        const fixedSources = {};
                        this.activeExternalSources.forEach(source => {
                            fixedSources[source] = true;
                        });
                        this.activeExternalSources = fixedSources;
                        
                        // Save the fixed structure
                        localStorage.setItem('ophthQA_activeSources', JSON.stringify(this.activeExternalSources));
                    }
                }
                
                if (savedPriorityCategories) {
                    this.priorityCategories = JSON.parse(savedPriorityCategories);
                }
            },
            
            // Import questions from Anki deck
            importQuestionsFromAnkiDeck: async function(deckUrl) {
                try {
                    // Show progress notification
                    const progressNotification = showNotification('Starting Anki deck import...', 'info');
                    
                    // Determine source type and extract relevant ID or URL
                    let sourceType = 'unknown';
                    let fileId = '';
                    
                    // Google Drive URL handling
                    if (deckUrl.includes('drive.google.com')) {
                        sourceType = 'google_drive';
                        const driveMatch = deckUrl.match(/[-\w]{25,}/);
                        if (driveMatch) {
                            fileId = driveMatch[0];
                        } else {
                            throw new Error('Invalid Google Drive URL format. Please ensure the sharing link is correct.');
                        }
                    } 
                    // Dropbox handling
                    else if (deckUrl.includes('dropbox.com')) {
                        sourceType = 'dropbox';
                        // Convert dropbox share link to direct download link
                        if (deckUrl.includes('?dl=0')) {
                            deckUrl = deckUrl.replace('?dl=0', '?dl=1');
                        } else if (!deckUrl.includes('?dl=1')) {
                            deckUrl += '?dl=1';
                        }
                    }
                    // Direct URL handling
                    else if (deckUrl.startsWith('http')) {
                        sourceType = 'direct_url';
                    }
                    // Local file ID handling (for demo purposes)
                    else {
                        sourceType = 'local_id';
                        fileId = deckUrl;
                    }
                    
                    // Update progress
                    progressNotification.innerHTML = '<p>Fetching Anki deck data...</p>';
                    
                    // Construct download URL based on source type
                    let downloadUrl = deckUrl;
                    if (sourceType === 'google_drive') {
                        downloadUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
                    }
                    
                    // Fetch the Anki deck JSON
                    const response = await fetch(downloadUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch Anki deck (HTTP ${response.status}). Check that the URL is accessible.`);
                    }
                    
                    // Parse the response based on content type
                    let deckData;
                    const contentType = response.headers.get('content-type');
                    
                    try {
                        if (contentType && contentType.includes('application/json')) {
                            deckData = await response.json();
                        } else {
                            // Try to parse as JSON anyway
                            const textData = await response.text();
                            deckData = JSON.parse(textData);
                        }
                    } catch (parseError) {
                        throw new Error(`Failed to parse Anki deck: ${parseError.message}. The file must be in JSON format.`);
                    }
                    
                    // Check for different Anki export formats
                    let cards = [];
                    let deckName = 'Imported Deck';
                    
                    // Update progress
                    progressNotification.innerHTML = '<p>Processing deck format...</p>';
                    
                    // Standard format with cards array
                    if (deckData.cards && Array.isArray(deckData.cards)) {
                        cards = deckData.cards;
                        if (deckData.name) deckName = deckData.name;
                    } 
                    // AnkiHub export format
                    else if (deckData.notes && Array.isArray(deckData.notes)) {
                        deckName = deckData.name || 'AnkiHub Import';
                        cards = deckData.notes.map(note => {
                            return {
                                question: note.fields ? note.fields[0] : note.front || 'Question not found',
                                answer: note.fields ? note.fields[1] : note.back || 'Answer not found',
                                tags: note.tags || []
                            };
                        });
                    }
                    // Anki Connect export format
                    else if (deckData.result && Array.isArray(deckData.result)) {
                        cards = deckData.result.map(item => {
                            return {
                                question: item.fields && item.fields.Front ? item.fields.Front.value : 'Question not found',
                                answer: item.fields && item.fields.Back ? item.fields.Back.value : 'Answer not found',
                                tags: item.tags || []
                            };
                        });
                    }
                    // Single card object format
                    else if (deckData.question && deckData.answer) {
                        cards = [deckData];
                    }
                    // Plain array of card objects
                    else if (Array.isArray(deckData) && deckData.length > 0) {
                        cards = deckData;
                    } else {
                        throw new Error('Unsupported Anki deck format. The file must contain cards in a recognizable format.');
                    }
                    
                    if (cards.length === 0) {
                        throw new Error('No cards found in the Anki deck.');
                    }
                    
                    // Update progress
                    progressNotification.innerHTML = `<p>Processing ${cards.length} cards...</p>`;
                    
                    // Check for duplicates
                    const existingQuestionTexts = new Set(this.questionDatabase.map(q => q.question));
                    const newCards = cards.filter(card => !existingQuestionTexts.has(card.question));
                    const duplicateCount = cards.length - newCards.length;
                    
                    let importedCount = 0;
                    let generatedMCQCount = 0;
                    
                    // Process each card in the deck
                    for (const card of newCards) {
                        if (card.question && card.answer) {
                            // Create a base question object
                            const newQuestion = {
                                id: 'anki_' + Date.now() + '_' + importedCount,
                                question: this.sanitizeHTML(card.question),
                                options: [],
                                correctAnswer: 0,
                                explanation: this.sanitizeHTML(card.answer),
                                category: this.extractCategoryFromTags(card.tags) || 'General Ophthalmology',
                                difficulty: card.difficulty || this.estimateDifficulty(card.question, card.answer),
                                source: 'Anki Import',
                                importDate: new Date().toISOString(),
                                stats: {
                                    attempts: 0,
                                    correct: 0
                                }
                            };
                            
                            // Handle question types based on content
                            if (card.options && Array.isArray(card.options) && card.options.length >= 2) {
                                // Card already has multiple choice options
                                newQuestion.options = card.options.map(opt => this.sanitizeHTML(opt));
                                newQuestion.correctAnswer = card.correctOption || 0;
                            } else {
                                // Convert flashcard to MCQ by extracting key points from answer
                                const mcqData = this.generateMCQFromFlashcard(card.question, card.answer);
                                newQuestion.options = mcqData.options;
                                newQuestion.correctAnswer = mcqData.correctAnswer;
                                
                                if (mcqData.isGenerated) {
                                    generatedMCQCount++;
                                }
                            }
                            
                            // Ensure we have at least 2 options
                            if (newQuestion.options.length < 2) {
                                newQuestion.options = ['True', 'False'];
                                newQuestion.correctAnswer = 0; // Default to True as correct
                            }
                            
                            // Add to database
                            this.questionDatabase.push(newQuestion);
                            importedCount++;
                            
                            // Check if the category exists in our list, if not, add it
                            if (!this.categories.includes(newQuestion.category)) {
                                this.categories.push(newQuestion.category);
                            }
                        }
                    }
                    
                    // Update progress
                    progressNotification.innerHTML = '<p>Saving questions to database...</p>';
                    
                    // Save the updated database
                    localStorage.setItem('ophthQA_database', JSON.stringify(this.questionDatabase));
                    
                    // After successful import, refresh the category buttons
                    refreshCategoryButtons();
                    
                    // Remove progress notification
                    document.body.removeChild(progressNotification);
                    
                    // Show summary notification
                    const summaryMessage = `Successfully imported ${importedCount} questions from "${deckName}" Anki deck. `
                        + (duplicateCount > 0 ? `${duplicateCount} duplicate(s) skipped. ` : '')
                        + (generatedMCQCount > 0 ? `${generatedMCQCount} flashcards converted to multiple-choice questions.` : '');
                    
                    showNotification(summaryMessage, 'success', 6000);
                    
                    return importedCount;
                } catch (error) {
                    console.error('Error importing Anki deck:', error);
                    
                    // Show a more detailed error message to the user
                    showNotification(`Error importing Anki deck: ${error.message}`, 'error', 10000);
                    
                    // Re-throw for caller to handle
                    throw error;
                }
            },
            
            // Sanitize HTML content to prevent XSS
            sanitizeHTML: function(html) {
                if (!html || typeof html !== 'string') return '';
                
                // Create a safe version of the HTML
                const doc = new DOMParser().parseFromString(html, 'text/html');
                
                // Extract text content and remove script tags
                const scripts = doc.querySelectorAll('script');
                scripts.forEach(script => script.remove());
                
                // If it has images, handle them specially to preserve them
                const images = doc.querySelectorAll('img');
                images.forEach(img => {
                    // Make sure src is safe
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('http'))) {
                        // Keep the image, but make it responsive
                        img.classList.add('clinical-image');
                        img.setAttribute('loading', 'lazy');
                    } else {
                        // Replace unsafe images
                        img.remove();
                    }
                });
                
                // Return the sanitized HTML
                return doc.body.innerHTML;
            },
            
            // Extract category from Anki tags
            extractCategoryFromTags: function(tags) {
                if (!tags || !Array.isArray(tags) || tags.length === 0) {
                    return null;
                }
                
                // Define common ophthalmology categories
                const ophthCategories = [
                    'Anterior Segment', 'Posterior Segment', 'Glaucoma', 'Neuro-ophthalmology',
                    'Pediatric Ophthalmology', 'Oculoplastics', 'General Ophthalmology',
                    'Retina', 'Cornea', 'Lens', 'Uveitis', 'Cataracts', 'Refractive'
                ];
                
                // Check if any tag matches our category list (case-insensitive)
                for (const tag of tags) {
                    const normalizedTag = tag.replace(/_/g, ' ').replace(/-/g, ' ');
                    
                    // Direct match
                    const directMatch = ophthCategories.find(cat => 
                        cat.toLowerCase() === normalizedTag.toLowerCase()
                    );
                    
                    if (directMatch) return directMatch;
                    
                    // Substring match
                    const partialMatch = ophthCategories.find(cat => 
                        normalizedTag.toLowerCase().includes(cat.toLowerCase())
                    );
                    
                    if (partialMatch) return partialMatch;
                }
                
                // If no match found, use the first tag as the category
                return tags[0].replace(/_/g, ' ').replace(/-/g, ' ');
            },
            
            // Estimate difficulty based on question and answer content
            estimateDifficulty: function(question, answer) {
                // Simple heuristics to estimate difficulty
                const combinedText = (question + answer).toLowerCase();
                
                // Count complexity indicators
                const difficultyWords = ['complex', 'difficult', 'challenging', 'advanced', 'rare', 'uncommon'];
                const easyWords = ['simple', 'basic', 'common', 'easy', 'straightforward'];
                
                let difficultyScore = 0;
                
                // Check for complex terms
                difficultyWords.forEach(word => {
                    if (combinedText.includes(word)) difficultyScore += 1;
                });
                
                // Check for easy terms
                easyWords.forEach(word => {
                    if (combinedText.includes(word)) difficultyScore -= 1;
                });
                
                // Long answers are typically more complex
                if (answer.length > 500) difficultyScore += 1;
                if (answer.length > 1000) difficultyScore += 1;
                
                // Questions with images are often more specific
                if (answer.includes('<img') || question.includes('<img')) difficultyScore += 1;
                
                // Return difficulty based on score
                if (difficultyScore >= 2) return 'Hard';
                if (difficultyScore <= -1) return 'Easy';
                return 'Medium';
            },
            
            // Generate multiple-choice options from a flashcard
            generateMCQFromFlashcard: function(question, answer) {
                // Default result with True/False options
                const defaultResult = {
                    options: ['True', 'False'],
                    correctAnswer: 0,
                    isGenerated: false
                };
                
                try {
                    // Strip HTML tags for text analysis
                    const plainAnswer = answer.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                    
                    // Check if the answer contains clear options (numbered or bulleted lists)
                    if (answer.includes('<li>') || plainAnswer.match(/\d+\.\s+/g)) {
                        // Extract list items from HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = answer;
                        
                        const listItems = Array.from(tempDiv.querySelectorAll('li')).map(li => li.textContent.trim());
                        
                        // If we found list items, use them as options
                        if (listItems.length >= 2) {
                            return {
                                options: listItems.slice(0, 4), // Limit to 4 options
                                correctAnswer: 0, // Assume first item is correct
                                isGenerated: true
                            };
                        }
                        
                        // Try to extract numbered list from plain text
                        const numberedItems = plainAnswer.split(/\d+\.\s+/).filter(item => item.trim().length > 0);
                        if (numberedItems.length >= 2) {
                            return {
                                options: numberedItems.slice(0, 4),
                                correctAnswer: 0,
                                isGenerated: true
                            };
                        }
                    }
                    
                    // Check for key phrases that indicate a specific answer
                    const keyPhrases = plainAnswer.match(/(?:is|are|can be|includes?|consists? of|defined as)\s+([^\.;]+)/gi);
                    
                    if (keyPhrases && keyPhrases.length > 0) {
                        // Extract the main answer from the first key phrase
                        const mainAnswer = keyPhrases[0].replace(/(?:is|are|can be|includes?|consists? of|defined as)\s+/i, '').trim();
                        
                        if (mainAnswer.length > 5 && mainAnswer.length < 100) {
                            // Generate plausible alternative options
                            const options = [mainAnswer];
                            
                            // Add some variations or opposites
                            if (mainAnswer.includes('increased')) {
                                options.push(mainAnswer.replace('increased', 'decreased'));
                            } else if (mainAnswer.includes('decreased')) {
                                options.push(mainAnswer.replace('decreased', 'increased'));
                            }
                            
                            if (mainAnswer.includes('high')) {
                                options.push(mainAnswer.replace('high', 'low'));
                            } else if (mainAnswer.includes('low')) {
                                options.push(mainAnswer.replace('low', 'high'));
                            }
                            
                            // Add "None of the above" as a fallback option
                            if (options.length < 2) {
                                options.push('None of the above');
                            }
                            
                            // Add another generic option if needed
                            if (options.length < 3) {
                                options.push('All of the above');
                            }
                            
                            // Add one more option if we have less than 4
                            if (options.length < 4 && keyPhrases.length > 1) {
                                const alternativeAnswer = keyPhrases[1].replace(/(?:is|are|can be|includes?|consists? of|defined as)\s+/i, '').trim();
                                if (alternativeAnswer.length > 5 && alternativeAnswer !== mainAnswer) {
                                    options.push(alternativeAnswer);
                                }
                            }
                            
                            return {
                                options: options,
                                correctAnswer: 0, // The main answer is always correct (first option)
                                isGenerated: true
                            };
                        }
                    }
                    
                    // If we couldn't generate a good MCQ, return the default True/False
                    return defaultResult;
                    
                } catch (error) {
                    console.warn('Error generating MCQ from flashcard:', error);
                    return defaultResult;
                }
            },
            
            // Calculate question difficulty
            calculateQuestionDifficulty: function(question) {
                if (!question.stats || question.stats.attempts < 5) {
                    return question.difficulty || 'Medium';
                }
                
                const correctRate = question.stats.correct / question.stats.attempts;
                
                if (correctRate < 0.3) {
                    return 'Hard';
                } else if (correctRate > 0.7) {
                    return 'Easy';
                } else {
                    return 'Medium';
                }
            },
            
            // Get a weighted random question based on user performance
            getWeightedRandomQuestion: function(category, requestedDifficulty) {
                // Filter questions based on category and active sources
                let filteredQuestions = this.questionDatabase.filter(q => {
                    // Filter by category if specified
                    if (category && category !== 'All' && q.category !== category) return false;
                    
                    // Source filtering - if activeExternalSources is defined and has entries
                    if (this.activeExternalSources && Object.keys(this.activeExternalSources).length > 0) {
                        // Map source types to activeExternalSources keys
                        let sourceType = 'sample'; // default
                        
                        if (q.source === 'Anki Import' || q.source === 'CSV Import') {
                            sourceType = 'user';
                        } else if (q.source && q.source.startsWith('api_')) {
                            sourceType = 'external';
                        }
                        
                        // Check if this source type is active
                        if (!this.activeExternalSources[sourceType]) {
                            return false;
                        }
                    }
                    
                    return true;
                });
                
                if (filteredQuestions.length === 0) {
                    return null;
                }
                
                // Determine recommended difficulty based on user performance
                let userPerformanceRate = 0;
                if (this.stats.totalQuestions > 0) {
                    userPerformanceRate = this.stats.correctAnswers / this.stats.totalQuestions;
                }
                
                // Determine target difficulty distribution based on performance and requested difficulty
                let easyWeight = 0.2, mediumWeight = 0.6, hardWeight = 0.2;
                
                // Adjust weights based on user performance
                if (userPerformanceRate < 0.4) {
                    // Struggling user - give more easy questions
                    easyWeight = 0.5;
                    mediumWeight = 0.4;
                    hardWeight = 0.1;
                } else if (userPerformanceRate > 0.8) {
                    // Advanced user - give more hard questions
                    easyWeight = 0.1;
                    mediumWeight = 0.4;
                    hardWeight = 0.5;
                }
                
                // Further adjust based on requested difficulty
                if (requestedDifficulty && requestedDifficulty !== 'All') {
                    if (requestedDifficulty === 'Easy') {
                        easyWeight = 0.7;
                        mediumWeight = 0.3;
                        hardWeight = 0;
                    } else if (requestedDifficulty === 'Medium') {
                        easyWeight = 0.2;
                        mediumWeight = 0.7;
                        hardWeight = 0.1;
                    } else if (requestedDifficulty === 'Hard') {
                        easyWeight = 0;
                        mediumWeight = 0.3;
                        hardWeight = 0.7;
                    }
                }
                
                const now = Date.now();
                
                // Calculate dynamic difficulty and weight for each question
                filteredQuestions.forEach(q => {
                    // Calculate dynamic difficulty
                    q.dynamicDifficulty = this.calculateQuestionDifficulty(q);
                    
                    // Base weight based on difficulty
                    switch (q.dynamicDifficulty) {
                        case 'Easy':
                            q.weight = easyWeight;
                            break;
                        case 'Medium':
                            q.weight = mediumWeight;
                            break;
                        case 'Hard':
                            q.weight = hardWeight;
                            break;
                        default:
                            q.weight = mediumWeight;
                    }
                    
                    // Spaced repetition factors
                    if (q.stats) {
                        // Time-based weighting (spaced repetition principle)
                        const lastAttemptTime = q.stats.lastAttemptTime || 0;
                        const daysSinceLastAttempt = (now - lastAttemptTime) / (1000 * 60 * 60 * 24);
                        
                        // Apply spaced repetition curve
                        if (lastAttemptTime > 0) {
                            // Just seen (less than 1 day ago) - reduce weight
                            if (daysSinceLastAttempt < 1) {
                                q.weight *= 0.3;
                            } 
                            // Optimal review interval based on previous performance
                            else {
                                const correctRate = q.stats.correct / q.stats.attempts;
                                let optimalInterval = 1; // Default: 1 day
                                
                                if (correctRate > 0.8) {
                                    // Well-remembered questions: longer interval
                                    optimalInterval = 7;
                                } else if (correctRate > 0.5) {
                                    // Moderately remembered: medium interval
                                    optimalInterval = 3;
                                }
                                
                                // Boost weight as we approach and exceed the optimal interval
                                // Peak at the optimal interval, then gradually decrease
                                const intervalRatio = daysSinceLastAttempt / optimalInterval;
                                if (intervalRatio > 0.8 && intervalRatio < 1.5) {
                                    // Near optimal interval - boost significantly
                                    q.weight *= 1.5;
                                } else if (intervalRatio >= 1.5 && intervalRatio < 3) {
                                    // Slightly overdue - maximum boost
                                    q.weight *= 2.0;
                                } else if (intervalRatio >= 3) {
                                    // Very overdue - still boosted but less so
                                    q.weight *= 1.7;
                                }
                            }
                        }
                        
                        // Boost questions answered incorrectly more times than correctly
                        if (q.stats.attempts > 0) {
                            if (q.stats.attempts > q.stats.correct) {
                                // More wrong than right - boost more
                                q.weight *= 1.4;
                                
                                // Extra boost for questions that are consistently wrong
                                if (q.stats.attempts > 2 && q.stats.correct / q.stats.attempts < 0.3) {
                                    q.weight *= 1.3; // Questions that are very difficult for this user
                                }
                            } else if (q.stats.correct / q.stats.attempts > 0.9 && q.stats.attempts > 2) {
                                // Well-mastered questions get reduced weight
                                q.weight *= 0.6;
                            }
                        }
                    } else {
                        // New questions (never attempted) get a boost
                        q.weight *= 1.5;
                    }
                    
                    // Priority categories (if any defined in user preferences)
                    if (this.priorityCategories && this.priorityCategories.includes(q.category)) {
                        q.weight *= 1.3;
                    }
                    
                    // Ensure weight is positive and reasonable
                    q.weight = Math.max(0.1, q.weight);
                });
                
                // Calculate total weight
                const totalWeight = filteredQuestions.reduce((sum, q) => sum + q.weight, 0);
                
                // If we somehow got zero total weight, reset all weights to 1
                if (totalWeight <= 0) {
                    filteredQuestions.forEach(q => q.weight = 1);
                    const newTotalWeight = filteredQuestions.length;
                    
                    // Pick a simple random question
                    return filteredQuestions[Math.floor(Math.random() * filteredQuestions.length)];
                }
                
                // Pick a random point in the weight range
                let random = Math.random() * totalWeight;
                
                // Find the question at that weight point
                let cumulativeWeight = 0;
                for (const question of filteredQuestions) {
                    cumulativeWeight += question.weight;
                    if (random <= cumulativeWeight) {
                        return question;
                    }
                }
                
                // Fallback to a simple random question if something went wrong
                return filteredQuestions[Math.floor(Math.random() * filteredQuestions.length)];
            },

            // Enhanced study tracking system
            getPerformanceInsights: function() {
                // No data yet
                if (this.stats.totalQuestions === 0) {
                    return {
                        insights: ["Start practicing to see personalized recommendations."],
                        weakCategories: [],
                        strongCategories: [],
                        recommendedCategories: []
                    };
                }
                
                const insights = [];
                const weakCategories = [];
                const strongCategories = [];
                let recommendedCategories = [];
                
                // Overall performance
                const overallAccuracy = this.stats.correctAnswers / this.stats.totalQuestions;
                if (overallAccuracy < 0.6) {
                    insights.push("Your overall accuracy is below 60%. Focus on building core knowledge before attempting mock exams.");
                } else if (overallAccuracy > 0.8) {
                    insights.push("Great job! Your overall accuracy is above 80%. You're ready for more challenging questions.");
                }
                
                // Analyze category performance
                const categories = Object.keys(this.categoryStats);
                categories.forEach(category => {
                    const stats = this.categoryStats[category];
                    
                    // Skip categories with very few questions
                    if (stats.questions < 5) return;
                    
                    const accuracy = stats.correct / stats.questions;
                    
                    if (accuracy < 0.6) {
                        weakCategories.push({
                            name: category,
                            accuracy: accuracy,
                            questions: stats.questions
                        });
                    } else if (accuracy > 0.8) {
                        strongCategories.push({
                            name: category,
                            accuracy: accuracy,
                            questions: stats.questions
                        });
                    }
                });
                
                // Sort weak categories by accuracy (ascending)
                weakCategories.sort((a, b) => a.accuracy - b.accuracy);
                
                // Sort strong categories by accuracy (descending)
                strongCategories.sort((a, b) => b.accuracy - a.accuracy);
                
                // Generate category-specific insights
                if (weakCategories.length > 0) {
                    const weakestCategory = weakCategories[0];
                    insights.push(`Your weakest area is ${weakestCategory.name} with ${Math.round(weakestCategory.accuracy * 100)}% accuracy. Focus on improving this area.`);
                    
                    // Add recommended study categories based on weaknesses
                    recommendedCategories = weakCategories.slice(0, 3).map(cat => cat.name);
                }
                
                if (strongCategories.length > 0) {
                    const strongestCategory = strongCategories[0];
                    insights.push(`Your strongest area is ${strongestCategory.name} with ${Math.round(strongestCategory.accuracy * 100)}% accuracy. Keep up the good work!`);
                }
                
                // Additional insights based on study patterns
                if (this.stats.totalQuestions < 50) {
                    insights.push("Try to complete at least 50 practice questions to get more accurate performance insights.");
                } else if (this.stats.examsCompleted === 0) {
                    insights.push("Consider taking a mock exam to assess your performance under exam conditions.");
                }
                
                // Get untouched categories
                const untouchedCategories = this.categories.filter(cat => !categories.includes(cat));
                if (untouchedCategories.length > 0) {
                    insights.push(`You haven't answered any questions in these categories: ${untouchedCategories.join(', ')}. Try exploring these areas.`);
                    
                    // Add some untouched categories to recommendations if we don't have enough weak categories
                    if (recommendedCategories.length < 3) {
                        const neededCategories = 3 - recommendedCategories.length;
                        recommendedCategories = recommendedCategories.concat(untouchedCategories.slice(0, neededCategories));
                    }
                }
                
                return {
                    insights,
                    weakCategories,
                    strongCategories,
                    recommendedCategories
                };
            },

            // Add a progress dashboard to the stats tab
            getPerformanceInsights: function() {
                // No data yet
                if (this.stats.totalQuestions === 0) {
                    return {
                        insights: ["Start practicing to see personalized recommendations."],
                        weakCategories: [],
                        strongCategories: [],
                        recommendedCategories: []
                    };
                }
                
                const insights = [];
                const weakCategories = [];
                const strongCategories = [];
                let recommendedCategories = [];
                
                // Overall performance
                const overallAccuracy = this.stats.correctAnswers / this.stats.totalQuestions;
                if (overallAccuracy < 0.6) {
                    insights.push("Your overall accuracy is below 60%. Focus on building core knowledge before attempting mock exams.");
                } else if (overallAccuracy > 0.8) {
                    insights.push("Great job! Your overall accuracy is above 80%. You're ready for more challenging questions.");
                }
                
                // Analyze category performance
                const categories = Object.keys(this.categoryStats);
                categories.forEach(category => {
                    const stats = this.categoryStats[category];
                    
                    // Skip categories with very few questions
                    if (stats.questions < 5) return;
                    
                    const accuracy = stats.correct / stats.questions;
                    
                    if (accuracy < 0.6) {
                        weakCategories.push({
                            name: category,
                            accuracy: accuracy,
                            questions: stats.questions
                        });
                    } else if (accuracy > 0.8) {
                        strongCategories.push({
                            name: category,
                            accuracy: accuracy,
                            questions: stats.questions
                        });
                    }
                });
                
                // Sort weak categories by accuracy (ascending)
                weakCategories.sort((a, b) => a.accuracy - b.accuracy);
                
                // Sort strong categories by accuracy (descending)
                strongCategories.sort((a, b) => b.accuracy - a.accuracy);
                
                // Generate category-specific insights
                if (weakCategories.length > 0) {
                    const weakestCategory = weakCategories[0];
                    insights.push(`Your weakest area is ${weakestCategory.name} with ${Math.round(weakestCategory.accuracy * 100)}% accuracy. Focus on improving this area.`);
                    
                    // Add recommended study categories based on weaknesses
                    recommendedCategories = weakCategories.slice(0, 3).map(cat => cat.name);
                }
                
                if (strongCategories.length > 0) {
                    const strongestCategory = strongCategories[0];
                    insights.push(`Your strongest area is ${strongestCategory.name} with ${Math.round(strongestCategory.accuracy * 100)}% accuracy. Keep up the good work!`);
                }
                
                // Additional insights based on study patterns
                if (this.stats.totalQuestions < 50) {
                    insights.push("Try to complete at least 50 practice questions to get more accurate performance insights.");
                } else if (this.stats.examsCompleted === 0) {
                    insights.push("Consider taking a mock exam to assess your performance under exam conditions.");
                }
                
                // Get untouched categories
                const untouchedCategories = this.categories.filter(cat => !categories.includes(cat));
                if (untouchedCategories.length > 0) {
                    insights.push(`You haven't answered any questions in these categories: ${untouchedCategories.join(', ')}. Try exploring these areas.`);
                    
                    // Add some untouched categories to recommendations if we don't have enough weak categories
                    if (recommendedCategories.length < 3) {
                        const neededCategories = 3 - recommendedCategories.length;
                        recommendedCategories = recommendedCategories.concat(untouchedCategories.slice(0, neededCategories));
                    }
                }
                
                return {
                    insights,
                    weakCategories,
                    strongCategories,
                    recommendedCategories
                };
            },

            // Add recent activity tracking
            recordActivity: function(activityType, details) {
                if (!this.activityLog) {
                    this.activityLog = [];
                }
                
                // Limit log size to prevent localStorage overflow
                if (this.activityLog.length >= 100) {
                    this.activityLog.pop(); // Remove oldest entry
                }
                
                // Add new activity to the beginning
                this.activityLog.unshift({
                    type: activityType,
                    details: details,
                    timestamp: new Date().toISOString()
                });
                
                // Save to localStorage
                localStorage.setItem('ophthQA_activityLog', JSON.stringify(this.activityLog));
            },

            // Load activity log from localStorage
            loadActivity: function() {
                const savedActivity = localStorage.getItem('ophthQA_activityLog');
                if (savedActivity) {
                    this.activityLog = JSON.parse(savedActivity);
                } else {
                    this.activityLog = [];
                }
            },

            // Set priority categories for focused learning
            setPriorityCategories: function(categories) {
                // Accept array of category names or single category name
                if (typeof categories === 'string') {
                    categories = [categories];
                }
                
                // Validate categories
                const validCategories = categories.filter(cat => 
                    this.categories.includes(cat)
                );
                
                this.priorityCategories = validCategories;
                localStorage.setItem('ophthQA_priorityCategories', JSON.stringify(validCategories));
                
                // Record activity
                if (typeof this.recordActivity === 'function') {
                    this.recordActivity('priority_categories_set', {
                        categories: validCategories
                    });
                }
                
                return validCategories;
            }
        };

        // Add initial DOM content loaded event handler
        document.addEventListener('DOMContentLoaded', () => {
            // Check storage and recover if necessary
            const storageOk = recoverFromStorageCorruption();
            
            // Load saved data
            simulator.loadStats();
            
            // Initialize database with sample questions if empty
            initializeDatabaseIfEmpty();
            
            // Fix home page layout
            improveHomePageLayout();
            
            // Initialize tabs correctly
            initializeTabs();
            
            // Load saved appearance settings
            loadAppearanceSettings();
            
            // Initialize category buttons
            refreshCategoryButtons();
            
            // Initialize difficulty buttons
            initializeDifficultyButtons();
            
            // Set up event listeners for question interface
            setupQuestionEventListeners();
            
            // Set up event listeners for exam interface
            setupExamEventListeners();
            
            // Initialize source selector
            initializeSourceSelector();
            
            // Load activity log
            simulator.loadActivity();
            
            // If running in a browser that doesn't support localStorage well (like some Safari versions)
            if (!storageOk) {
                showNotification('Running in memory-only mode. Your data will not be saved between sessions.', 'warning', 10000);
            }
        });

        // Function to initialize tabs correctly
        function initializeTabs() {
            // Set initial tab states
            tabPanels.forEach(panel => {
                if (!panel.classList.contains('active')) {
                    panel.setAttribute('hidden', 'true');
                } else {
                    panel.removeAttribute('hidden');
                }
            });
            
            tabButtons.forEach(btn => {
                if (btn.classList.contains('active')) {
                    btn.setAttribute('aria-selected', 'true');
                } else {
                    btn.setAttribute('aria-selected', 'false');
                }
            });
            
            // Override any existing handlers with our fixed version
            tabButtons.forEach(button => {
                // Remove existing handlers to avoid duplicates
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
                
                // Add our fixed click handler
                newButton.addEventListener('click', function() {
                    const tabName = this.dataset.tab;
                    
                    // Update active tab button
                    tabButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-selected', 'false');
                    });
                    this.classList.add('active');
                    this.setAttribute('aria-selected', 'true');
                    
                    // Show selected tab panel
                    tabPanels.forEach(panel => {
                        panel.classList.remove('active');
                        panel.setAttribute('hidden', 'true');
                    });
                    
                    const targetPanel = document.getElementById(tabName);
                    if (targetPanel) {
                        targetPanel.classList.add('active');
                        targetPanel.removeAttribute('hidden');
                        
                        // Update specific tab content
                        if (tabName === 'stats' && typeof updateStatsDisplay === 'function') {
                            setTimeout(updateStatsDisplay, 50);  // Slight delay to ensure DOM is ready
                        } else if (tabName === 'review' && typeof updateReviewDisplay === 'function') {
                            setTimeout(updateReviewDisplay, 50);
                        }
                    }
                });
                
                // Add keyboard navigation
                newButton.addEventListener('keydown', function(e) {
                    const buttons = Array.from(tabButtons);
                    const currentIndex = buttons.indexOf(this);
                    let nextIndex;
                    
                    switch (e.key) {
                        case 'ArrowRight':
                        case 'ArrowDown':
                            e.preventDefault();
                            nextIndex = currentIndex + 1;
                            if (nextIndex >= buttons.length) nextIndex = 0;
                            buttons[nextIndex].focus();
                            break;
                        case 'ArrowLeft':
                        case 'ArrowUp':
                            e.preventDefault();
                            nextIndex = currentIndex - 1;
                            if (nextIndex < 0) nextIndex = buttons.length - 1;
                            buttons[nextIndex].focus();
                            break;
                        case 'Home':
                            e.preventDefault();
                            buttons[0].focus();
                            break;
                        case 'End':
                            e.preventDefault();
                            buttons[buttons.length - 1].focus();
                            break;
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            this.click();
                            break;
                    }
                });
            });
        }

        // Function to improve home page layout
        function improveHomePageLayout() {
            // Fix welcome banner
            const welcomeBanner = document.querySelector('.welcome-banner');
            if (welcomeBanner) {
                welcomeBanner.style.marginBottom = '30px';
            }
            
            // Ensure the sources container is displayed correctly
            const sourcesContainer = document.querySelector('.sources-container');
            if (sourcesContainer) {
                if (window.innerWidth < 768) {
                    sourcesContainer.style.gridTemplateColumns = '1fr';
                } else {
                    sourcesContainer.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
                }
            }
            
            // Fix practice card margin
            const practiceCard = document.querySelector('.practice-card');
            if (practiceCard) {
                practiceCard.style.marginBottom = '30px';
            }
            
            // Fix button styles for touchscreen devices
            const allButtons = document.querySelectorAll('button:not([disabled])');
            allButtons.forEach(button => {
                button.style.cursor = 'pointer';
                button.addEventListener('touchstart', function() {
                    this.style.opacity = '0.8';
                });
                button.addEventListener('touchend', function() {
                    this.style.opacity = '1';
                });
            });
            
            // Fix option buttons in the question card
            const optionButtons = document.querySelectorAll('.option-btn');
            optionButtons.forEach(button => {
                button.style.transition = 'background-color 0.2s, color 0.2s';
            });
            
            // Fix form spacing
            const formGroups = document.querySelectorAll('.form-group');
            formGroups.forEach(group => {
                group.style.marginBottom = '20px';
            });
        }

        // Function to load appearance settings
        function loadAppearanceSettings() {
            // Check for dark mode
            if (localStorage.getItem('ophthQA_darkMode') === 'true') {
                document.body.classList.add('dark-mode');
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) darkModeToggle.checked = true;
            }
            
            // Check for high contrast
            if (localStorage.getItem('ophthQA_highContrast') === 'true') {
                document.body.classList.add('high-contrast');
                const highContrastToggle = document.getElementById('highContrastToggle');
                if (highContrastToggle) highContrastToggle.checked = true;
            }
            
            // Check for font size
            const savedFontSize = localStorage.getItem('ophthQA_fontSize');
            if (savedFontSize) {
                document.body.classList.add(`font-${savedFontSize}`);
                const fontSizeSelector = document.getElementById('fontSizeSelector');
                if (fontSizeSelector) fontSizeSelector.value = savedFontSize;
            }
        }

        // Function to update category buttons
        function refreshCategoryButtons() {
            const categoryButtons = document.getElementById('categoryButtons');
            if (categoryButtons) {
                categoryButtons.innerHTML = '';
                
                // Add "All Categories" button
                const allButton = document.createElement('button');
                allButton.className = 'btn btn-secondary active';
                allButton.textContent = 'All Categories';
                allButton.addEventListener('click', () => {
                    // Remove active class from all category buttons
                    document.querySelectorAll('#categoryButtons .btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    allButton.classList.add('active');
                    
                    const difficulty = document.querySelector('.difficulty-btn.active')?.dataset.difficulty || 'All';
                    displayRandomQuestion('All', difficulty);
                });
                categoryButtons.appendChild(allButton);
                
                // Add individual category buttons
                simulator.categories.forEach(category => {
                    const button = document.createElement('button');
                    button.className = 'btn btn-secondary';
                    button.textContent = category;
                    button.addEventListener('click', () => {
                        // Remove active class from all category buttons
                        document.querySelectorAll('#categoryButtons .btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        button.classList.add('active');
                        
                        const difficulty = document.querySelector('.difficulty-btn.active')?.dataset.difficulty || 'All';
                        displayRandomQuestion(category, difficulty);
                    });
                    categoryButtons.appendChild(button);
                });
            }
            
            // Also refresh priority categories selector
            initializePriorityCategories();
        }

        // Function to initialize priority categories UI
        function initializePriorityCategories() {
            const priorityCategoriesSelector = document.getElementById('priorityCategoriesSelector');
            if (!priorityCategoriesSelector) return;
            
            // Clear existing content
            priorityCategoriesSelector.innerHTML = '';
            
            // Create a checkbox for each category
            simulator.categories.forEach(category => {
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.className = 'checkbox-wrapper';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `priority-${category.replace(/\s+/g, '-').toLowerCase()}`;
                checkbox.value = category;
                
                // Check if this category is already a priority
                if (simulator.priorityCategories && simulator.priorityCategories.includes(category)) {
                    checkbox.checked = true;
                }
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = category;
                
                checkboxWrapper.appendChild(checkbox);
                checkboxWrapper.appendChild(label);
                priorityCategoriesSelector.appendChild(checkboxWrapper);
            });
            
            // Set up save button event listener
            const savePriorityBtn = document.getElementById('savePriorityBtn');
            if (savePriorityBtn) {
                // Remove any existing event listeners by cloning and replacing
                const newSaveBtn = savePriorityBtn.cloneNode(true);
                savePriorityBtn.parentNode.replaceChild(newSaveBtn, savePriorityBtn);
                
                // Add new event listener
                newSaveBtn.addEventListener('click', function() {
                    const selectedCategories = [];
                    const checkboxes = document.querySelectorAll('#priorityCategoriesSelector input[type="checkbox"]:checked');
                    
                    checkboxes.forEach(checkbox => {
                        selectedCategories.push(checkbox.value);
                    });
                    
                    // Save the priority categories
                    simulator.setPriorityCategories(selectedCategories);
                    
                    // Show confirmation
                    showNotification(`Priority focus areas updated: ${selectedCategories.length > 0 ? selectedCategories.join(', ') : 'None'}`, 'success');
                });
            }
        }
        
        // Helper function to show notifications
        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<p>${message}</p>`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }
            }, duration);
        }

        // Function to update stats display
        function updateStatsDisplay() {
            // Update main stats
            const totalQuestions = document.getElementById('totalQuestions');
            const correctAnswers = document.getElementById('correctAnswers');
            const accuracyRate = document.getElementById('accuracyRate');
            const examsCompleted = document.getElementById('examsCompleted');
            
            totalQuestions.textContent = simulator.stats.totalQuestions || 0;
            correctAnswers.textContent = simulator.stats.correctAnswers || 0;
            
            const accuracy = simulator.stats.totalQuestions > 0 ? 
                Math.round((simulator.stats.correctAnswers / simulator.stats.totalQuestions) * 100) : 0;
            accuracyRate.textContent = `${accuracy}%`;
            
            examsCompleted.textContent = simulator.stats.examsCompleted || 0;
            
            // Update category stats
            const categoryStatsTable = document.getElementById('categoryStats');
            const tableBody = categoryStatsTable.querySelector('tbody');
            tableBody.innerHTML = '';
            
            // Get all categories with stats
            const categoriesWithStats = Object.keys(simulator.categoryStats);
            
            if (categoriesWithStats.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 4;
                cell.textContent = 'No data available yet. Complete some questions to see statistics.';
                cell.style.textAlign = 'center';
                row.appendChild(cell);
                tableBody.appendChild(row);
            } else {
                categoriesWithStats.forEach(category => {
                    const stats = simulator.categoryStats[category];
                    const row = document.createElement('tr');
                    
                    const categoryCell = document.createElement('td');
                    categoryCell.textContent = category;
                    
                    const questionsCell = document.createElement('td');
                    questionsCell.textContent = stats.questions;
                    
                    const correctCell = document.createElement('td');
                    correctCell.textContent = stats.correct;
                    
                    const accuracyCell = document.createElement('td');
                    const catAccuracy = stats.questions > 0 ? 
                        Math.round((stats.correct / stats.questions) * 100) : 0;
                    accuracyCell.textContent = `${catAccuracy}%`;
                    
                    row.appendChild(categoryCell);
                    row.appendChild(questionsCell);
                    row.appendChild(correctCell);
                    row.appendChild(accuracyCell);
                    
                    tableBody.appendChild(row);
                });
            }
            
            // Call enhanced stats display
            enhanceStatsDisplay();
        }

        // Function to update review display
        function updateReviewDisplay() {
            const reviewCategory = document.getElementById('reviewCategory');
            const missedQuestionsContainer = document.getElementById('missedQuestionsContainer');
            
            // Clear existing options
            reviewCategory.innerHTML = '<option value="all">All Categories</option>';
            
            // Add all categories with stats
            const categoriesWithStats = Object.keys(simulator.categoryStats);
            categoriesWithStats.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                reviewCategory.appendChild(option);
            });
            
            // Set up change handler
            reviewCategory.addEventListener('change', displayMissedQuestions);
            
            // Display initial missed questions
            displayMissedQuestions();
        }

        // Function to display missed questions
        function displayMissedQuestions() {
            const reviewCategory = document.getElementById('reviewCategory');
            const selectedCategory = reviewCategory.value;
            const missedQuestionsContainer = document.getElementById('missedQuestionsContainer');
            
            // Clear container
            missedQuestionsContainer.innerHTML = '';
            
            // Filter questions to find missed ones
            const missedQuestions = simulator.questionDatabase.filter(q => {
                // Check if question has stats and has been missed at least once
                if (!q.stats || q.stats.attempts === 0) return false;
                
                // Check if question has been answered incorrectly at least once
                if (q.stats.attempts <= q.stats.correct) return false;
                
                // Check category filter
                if (selectedCategory !== 'all' && q.category !== selectedCategory) return false;
                
                return true;
            });
            
            if (missedQuestions.length === 0) {
                missedQuestionsContainer.innerHTML = '<p>No missed questions found. Keep practicing!</p>';
                return;
            }
            
            // Add a heading
            const heading = document.createElement('h3');
            heading.textContent = `Missed Questions (${missedQuestions.length})`;
            missedQuestionsContainer.appendChild(heading);
            
            // Display each missed question
            missedQuestions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'anki-card';
                
                const questionHeader = document.createElement('div');
                questionHeader.className = 'anki-question';
                questionHeader.textContent = `${index + 1}. ${question.question}`;
                
                const statsInfo = document.createElement('div');
                statsInfo.innerHTML = `<strong>Category:</strong> ${question.category} | <strong>Difficulty:</strong> ${question.difficulty} | 
                                     <strong>Accuracy:</strong> ${question.stats.correct}/${question.stats.attempts} 
                                     (${Math.round((question.stats.correct / question.stats.attempts) * 100)}%)`;
                statsInfo.style.marginBottom = '10px';
                
                const correctAnswer = document.createElement('div');
                correctAnswer.innerHTML = `<strong>Correct answer:</strong> ${question.options[question.correctAnswer]}`;
                
                const explanation = document.createElement('div');
                explanation.className = 'anki-answer';
                explanation.innerHTML = `<strong>Explanation:</strong> ${question.explanation}`;
                
                questionDiv.appendChild(questionHeader);
                questionDiv.appendChild(statsInfo);
                questionDiv.appendChild(correctAnswer);
                questionDiv.appendChild(explanation);
                
                missedQuestionsContainer.appendChild(questionDiv);
            });
        }

        // Function to process CSV import
        function processCSVImport(csvContent) {
            // Split by rows
            const rows = csvContent.split(/\r\n|\n/);
            
            if (rows.length < 2) {
                throw new Error('CSV file is empty or invalid');
            }
            
            let importedCount = 0;
            
            // Process each row (skip header row if present)
            for (let i = 1; i < rows.length; i++) {
                // Ignore empty rows
                if (!rows[i].trim()) continue;
                
                // Split by commas, but handle commas within quotes
                const columns = rows[i].match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
                
                // Remove quotes and trim whitespace
                for (let j = 0; j < columns.length; j++) {
                    columns[j] = columns[j].replace(/^"|"$/g, '').trim();
                }
                
                // Check if we have enough columns
                if (columns.length < 6) {
                    console.warn(`Skipping row ${i}: not enough columns`);
                    continue;
                }
                
                // Extract data
                const question = columns[0];
                const options = [columns[1], columns[2], columns[3], columns[4]];
                const correctAnswer = parseInt(columns[5]) - 1; // Assuming 1-based indexing in CSV
                const explanation = columns[6] || 'No explanation provided';
                const category = columns[7] || 'General Ophthalmology';
                const difficulty = columns[8] || 'Medium';
                
                // Create new question object
                const newQuestion = {
                    id: 'csv_' + Date.now() + '_' + importedCount,
                    question,
                    options,
                    correctAnswer,
                    explanation,
                    category,
                    difficulty,
                    source: 'CSV Import',
                    stats: {
                        attempts: 0,
                        correct: 0
                    }
                };
                
                // Add to database
                simulator.questionDatabase.push(newQuestion);
                importedCount++;
                
                // Check if the category exists in our list, if not, add it
                if (!simulator.categories.includes(newQuestion.category)) {
                    simulator.categories.push(newQuestion.category);
                }
            }
            
            // Save the updated database
            localStorage.setItem('ophthQA_database', JSON.stringify(simulator.questionDatabase));
            
            // Refresh category buttons using the dedicated function
            refreshCategoryButtons();
            
            return importedCount;
        }

        // Variables to track current state
        let currentDifficulty = 'All';

        // Re-add error handling improvements
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e.error || e.message);
            
            // Only show error to user if it's likely to affect functionality
            if (e.error && !e.filename.includes('extension') && !e.filename.includes('chrome')) {
                const errorMessage = document.createElement('div');
                errorMessage.className = 'notification error';
                errorMessage.innerHTML = `<p>An error occurred. Please refresh the page.</p>`;
                document.body.appendChild(errorMessage);
                
                setTimeout(() => {
                    if (document.body.contains(errorMessage)) {
                        document.body.removeChild(errorMessage);
                    }
                }, 5000);
            }
            
            return false;
        });

        // Re-add online/offline notification
        window.addEventListener('online', function() {
            const notification = document.createElement('div');
            notification.className = 'notification success';
            notification.innerHTML = '<p>You are back online. All features are now available.</p>';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        });

        window.addEventListener('offline', function() {
            const notification = document.createElement('div');
            notification.className = 'notification error';
            notification.innerHTML = '<p>You are offline. Some features may not be available.</p>';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 5000);
        });

        // Add DOM element caching for performance
        const cachedElements = {};
        function getElement(id) {
            if (!cachedElements[id]) {
                cachedElements[id] = document.getElementById(id);
            }
            return cachedElements[id];
        }

        // Update processCSVImport function
        function processCSVImport(csvContent) {
            // ... existing code ...
            
            // Save the updated database
            localStorage.setItem('ophthQA_database', JSON.stringify(simulator.questionDatabase));
            
            // Refresh category buttons using the dedicated function
            refreshCategoryButtons();
            
            return importedCount;
        }

        // Update importQuestionsFromAnkiDeck
        simulator.importQuestionsFromAnkiDeck = async function(deckUrl) {
            try {
                // ... existing code ...
                
                // After successful import, refresh the category buttons
                refreshCategoryButtons();
                
                return importedCount;
            } catch (error) {
                // ... existing code ...
            }
        };

        // Re-add the performance optimizations
        document.addEventListener('DOMContentLoaded', function() {
            // Lazy load all images
            const lazyImages = document.querySelectorAll('img:not([loading])');
            lazyImages.forEach(img => {
                img.setAttribute('loading', 'lazy');
                
                // Add error handling for images
                img.addEventListener('error', function() {
                    this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjYWFhIj5JbWFnZSBFcnJvcjwvdGV4dD48L3N2Zz4=';
                    this.alt = 'Image failed to load';
                });
            });
            
            // Set up appearance settings event listeners
            const darkModeToggle = document.getElementById('darkModeToggle');
            if (darkModeToggle) {
                darkModeToggle.addEventListener('change', function() {
                    if (this.checked) {
                        document.body.classList.add('dark-mode');
                        localStorage.setItem('ophthQA_darkMode', 'true');
                    } else {
                        document.body.classList.remove('dark-mode');
                        localStorage.setItem('ophthQA_darkMode', 'false');
                    }
                });
            }
            
            const highContrastToggle = document.getElementById('highContrastToggle');
            if (highContrastToggle) {
                highContrastToggle.addEventListener('change', function() {
                    if (this.checked) {
                        document.body.classList.add('high-contrast');
                        localStorage.setItem('ophthQA_highContrast', 'true');
                    } else {
                        document.body.classList.remove('high-contrast');
                        localStorage.setItem('ophthQA_highContrast', 'false');
                    }
                });
            }
            
            const fontSizeSelector = document.getElementById('fontSizeSelector');
            if (fontSizeSelector) {
                fontSizeSelector.addEventListener('change', function() {
                    // Remove existing font size classes
                    document.body.classList.remove('font-small', 'font-medium', 'font-large');
                    // Add selected font size class
                    document.body.classList.add(`font-${this.value}`);
                    // Save to localStorage
                    localStorage.setItem('ophthQA_fontSize', this.value);
                });
            }
            
            // Debounce function to optimize event listeners
            function debounce(func, wait) {
                let timeout;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        func.apply(context, args);
                    }, wait);
                };
            }
            
            // Optimize search inputs with debounce
            const searchInputs = document.querySelectorAll('input[type="search"], input[id*="search"]');
            searchInputs.forEach(input => {
                const originalHandler = input.oninput;
                if (typeof originalHandler === 'function') {
                    input.oninput = null;
                    input.addEventListener('input', debounce(originalHandler, 300));
                }
            });
            
            // Add loading state to buttons that perform async operations
            const asyncButtons = document.querySelectorAll('#importAnkiBtn, #importAnkiBtnSettings, #uploadCsvBtn, #exportDataBtn');
            asyncButtons.forEach(button => {
                button.addEventListener('click', async function(e) {
                    // Only process if button doesn't already have loading state
                    if (!this.classList.contains('loading')) {
                        this.classList.add('loading');
                        
                        try {
                            // For simulator.importQuestionsFromAnkiDeck
                            if (this.id === 'importAnkiBtn') {
                                const deckUrl = document.getElementById('ankiDeckUrl').value.trim();
                                if (!deckUrl) {
                                    alert('Please enter a valid Anki deck URL');
                                    return;
                                }
                                await simulator.importQuestionsFromAnkiDeck(deckUrl);
                            }
                            else if (this.id === 'importAnkiBtnSettings') {
                                const deckUrl = document.getElementById('ankiDeckUrlSettings').value.trim();
                                if (!deckUrl) {
                                    alert('Please enter a valid Anki deck URL');
                                    return;
                                }
                                await simulator.importQuestionsFromAnkiDeck(deckUrl);
                            }
                            else if (this.id === 'exportDataBtn') {
                                // Get all data from localStorage
                                const exportData = {
                                    stats: simulator.stats,
                                    questionDatabase: simulator.questionDatabase,
                                    categoryStats: simulator.categoryStats,
                                    apiKeys: simulator.apiKeys,
                                    activeExternalSources: simulator.activeExternalSources
                                };
                                
                                // Create a download link
                                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData));
                                const downloadAnchorNode = document.createElement('a');
                                downloadAnchorNode.setAttribute("href", dataStr);
                                downloadAnchorNode.setAttribute("download", "ophth_qa_data.json");
                                document.body.appendChild(downloadAnchorNode);
                                downloadAnchorNode.click();
                                downloadAnchorNode.remove();
                            }
                            // For the CSV upload button
                            else if (this.id === 'uploadCsvBtn') {
                                const fileInput = document.getElementById('csvFileInput');
                                if (fileInput.files.length > 0) {
                                    const file = fileInput.files[0];
                                    const reader = new FileReader();
                                    reader.onload = function(e) {
                                        try {
                                            const csvContent = e.target.result;
                                            const importedCount = processCSVImport(csvContent);
                                            
                                            // Show success notification
                                            const notification = document.createElement('div');
                                            notification.className = 'notification success';
                                            notification.innerHTML = `<p>Successfully imported ${importedCount} questions from CSV!</p>`;
                                            document.body.appendChild(notification);
                                            
                                            // Remove notification after delay
                                            setTimeout(() => {
                                                if (document.body.contains(notification)) {
                                                    document.body.removeChild(notification);
                                                }
                                            }, 3000);
                                            
                                        } catch (error) {
                                            // Show error notification
                                            const notification = document.createElement('div');
                                            notification.className = 'notification error';
                                            notification.innerHTML = `<p>Error importing questions: ${error.message}</p>`;
                                            document.body.appendChild(notification);
                                            
                                            // Remove notification after delay
                                            setTimeout(() => {
                                                if (document.body.contains(notification)) {
                                                    document.body.removeChild(notification);
                                                }
                                            }, 5000);
                                        }
                                    };
                                    reader.readAsText(file);
                                } else {
                                    showNotification('Please select a CSV file first', 'error');
                                }
                            }
                        } catch (error) {
                            console.error('Error in button action:', error);
                            // Show error notification
                            showNotification(`Error: ${error.message}`, 'error');
                        } finally {
                            this.classList.remove('loading');
                        }
                    }
                });
            });
            
            // Add event listeners for data management buttons
            const resetStatsBtn = document.getElementById('resetStatsBtn');
            if (resetStatsBtn) {
                resetStatsBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to reset all your statistics? This action cannot be undone.')) {
                        // Reset stats
                        simulator.stats = {
                            totalQuestions: 0,
                            correctAnswers: 0,
                            examsCompleted: 0
                        };
                        simulator.categoryStats = {};
                        
                        // Save to localStorage
                        localStorage.setItem('ophthQA_stats', JSON.stringify(simulator.stats));
                        localStorage.setItem('ophthQA_categoryStats', JSON.stringify(simulator.categoryStats));
                        
                        // Show success notification
                        showNotification('Statistics have been reset successfully!', 'success');
                        
                        // Update stats display if on stats tab
                        if (typeof updateStatsDisplay === 'function') {
                            updateStatsDisplay();
                        }
                    }
                });
            }
            
            const clearLocalDbBtn = document.getElementById('clearLocalDbBtn');
            if (clearLocalDbBtn) {
                clearLocalDbBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear your local question database? This will remove all imported questions. This action cannot be undone.')) {
                        // Clear local database
                        simulator.questionDatabase = [];
                        
                        // Save to localStorage
                        localStorage.setItem('ophthQA_database', JSON.stringify(simulator.questionDatabase));
                        
                        // Show success notification
                        showNotification('Local question database has been cleared successfully!', 'success');
                        
                        // Refresh category buttons
                        refreshCategoryButtons();
                    }
                });
            }
        });

        // Helper function to show notifications
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<p>${message}</p>`;
            document.body.appendChild(notification);
            
            // Remove notification after delay
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    
                    // Remove from DOM after animation
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }
            }, type === 'error' ? 5000 : 3000);
            
            return notification;
        }

        // Add keyboard navigation for accessibility
        function setupKeyboardNavigation() {
            // Handle keyboard navigation in question options
            document.addEventListener('keydown', function(e) {
                // Only handle if we're in question view
                const questionCard = document.getElementById('questionCard');
                const examContent = document.getElementById('examContent');
                
                if ((questionCard && !questionCard.classList.contains('hidden')) || 
                    (examContent && !examContent.classList.contains('hidden'))) {
                    
                    // Get all option buttons
                    const optionButtons = document.querySelectorAll('.option-btn');
                    
                    // Handle number keys 1-4 for selecting options
                    if (e.key >= '1' && e.key <= '4' && optionButtons.length >= parseInt(e.key)) {
                        const index = parseInt(e.key) - 1;
                        optionButtons[index].click();
                        return;
                    }
                    
                    // Handle submit with Enter
                    if (e.key === 'Enter') {
                        const submitBtn = document.getElementById('submitAnswerBtn');
                        const nextBtn = document.getElementById('nextQuestionBtn');
                        
                        if (submitBtn && !submitBtn.classList.contains('hidden') && !submitBtn.disabled) {
                            submitBtn.click();
                            return;
                        }
                        
                        if (nextBtn && !nextBtn.classList.contains('hidden')) {
                            nextBtn.click();
                            return;
                        }
                    }
                }
            });
        }

        // Register service worker for offline capability
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async function() {
                try {
                    // First try to use an external service worker file
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    } catch (err) {
                        // If external file fails, create a dynamic service worker
                        console.log('External ServiceWorker registration failed, trying inline version');
                        
                        const swContent = `
                            // Simple service worker for offline caching
                            const CACHE_NAME = 'frcs-simulator-cache-v1';
                            const urlsToCache = [
                                '${window.location.pathname}',
                                'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap'
                            ];

                            self.addEventListener('install', function(event) {
                                // Perform install steps
                                event.waitUntil(
                                    caches.open(CACHE_NAME)
                                        .then(function(cache) {
                                            return cache.addAll(urlsToCache);
                                        })
                                );
                            });

                            self.addEventListener('fetch', function(event) {
                                event.respondWith(
                                    caches.match(event.request)
                                        .then(function(response) {
                                            // Cache hit - return response
                                            if (response) {
                                                return response;
                                            }
                                            return fetch(event.request).then(
                                                function(response) {
                                                    // Check if we received a valid response
                                                    if(!response || response.status !== 200 || response.type !== 'basic') {
                                                        return response;
                                                    }

                                                    // Clone the response
                                                    var responseToCache = response.clone();

                                                    caches.open(CACHE_NAME)
                                                        .then(function(cache) {
                                                            cache.put(event.request, responseToCache);
                                                        });

                                                    return response;
                                                }
                                            );
                                        })
                                );
                            });
                        `;
                        
                        // Create a Blob containing the service worker code
                        const blob = new Blob([swContent], {type: 'application/javascript'});
                        const swUrl = URL.createObjectURL(blob);
                        
                        // Register the service worker from the Blob URL
                        const blobRegistration = await navigator.serviceWorker.register(swUrl, {scope: './'});
                        console.log('Service worker registered from blob:', blobRegistration.scope);
                    }
                } catch (e) {
                    console.error('Service worker registration completely failed:', e);
                }
            });
        }

        // Add this to the DOMContentLoaded event
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Set up keyboard navigation
            setupKeyboardNavigation();
            
            // Add tab index to all interactive elements
            document.querySelectorAll('button, input, select, a, [role="button"]').forEach((element, index) => {
                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }
            });
            
            // Initialize stats tab
            const statsTab = document.getElementById('tab-stats');
            if (statsTab) {
                statsTab.addEventListener('click', function() {
                    setTimeout(updateStatsDisplay, 50);
                });
            }
            
            // Initialize review tab
            const reviewTab = document.getElementById('tab-review');
            if (reviewTab) {
                reviewTab.addEventListener('click', function() {
                    setTimeout(updateReviewDisplay, 50);
                });
            }
        });

        // Function to initialize difficulty buttons
        function initializeDifficultyButtons() {
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    difficultyButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentDifficulty = this.dataset.difficulty;
                });
            });
        }

        // Debug function to help diagnose source filtering issues
        function debugSourceFiltering(category, difficulty) {
            const sourceFilterInfo = {
                activeSourcesConfig: {...simulator.activeExternalSources},
                databaseStats: {
                    totalQuestions: simulator.questionDatabase.length,
                    byCategory: {},
                    bySource: {}
                }
            };
            
            // Count questions by category and source
            simulator.questionDatabase.forEach(q => {
                // By category
                if (!sourceFilterInfo.databaseStats.byCategory[q.category]) {
                    sourceFilterInfo.databaseStats.byCategory[q.category] = 0;
                }
                sourceFilterInfo.databaseStats.byCategory[q.category]++;
                
                // By source
                let sourceType = q.source || 'sample';
                if (!sourceFilterInfo.databaseStats.bySource[sourceType]) {
                    sourceFilterInfo.databaseStats.bySource[sourceType] = 0;
                }
                sourceFilterInfo.databaseStats.bySource[sourceType]++;
            });
            
            // Return diagnostic info
            return sourceFilterInfo;
        }
        
        // Function to display a random question
        function displayRandomQuestion(category, difficulty) {
            const question = simulator.getWeightedRandomQuestion(category, difficulty);
            
            if (!question) {
                // Get debug info
                const debugInfo = debugSourceFiltering(category, difficulty);
                
                // Create a more helpful error message
                let errorMessage = 'No questions available with the selected criteria. Try different filters.';
                
                // Add more context if we have no questions at all
                if (debugInfo.databaseStats.totalQuestions === 0) {
                    errorMessage = 'Your question database is empty. Please import some questions or use the sample questions.';
                }
                // Or if we have questions but source filters are too restrictive
                else if (Object.keys(debugInfo.activeSourcesConfig).length > 0 && 
                         Object.values(debugInfo.activeSourcesConfig).every(v => v === false)) {
                    errorMessage = 'All question sources are disabled. Please enable at least one source.';
                }
                
                // Show diagnostic info in console for troubleshooting
                console.log('Question filter diagnostic info:', debugInfo);
                
                const notification = document.createElement('div');
                notification.className = 'notification error';
                notification.innerHTML = `<p>${errorMessage}</p>`;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 5000);
                return;
            }
            
            simulator.currentQuestion = question;
            
            // Update UI with question data
            const questionCard = document.getElementById('questionCard');
            const questionText = document.getElementById('questionText');
            const questionCategory = document.getElementById('questionCategory');
            const optionsContainer = document.getElementById('optionsContainer');
            const submitButton = document.getElementById('submitAnswerBtn');
            const nextButton = document.getElementById('nextQuestionBtn');
            const explanation = document.getElementById('explanation');
            
            // Reset UI state
            submitButton.disabled = true;
            submitButton.classList.remove('hidden');
            nextButton.classList.add('hidden');
            explanation.classList.add('hidden');
            questionCard.classList.remove('hidden');
            
            // Set question text and category
            questionText.textContent = question.question;
            questionCategory.textContent = `Category: ${question.category} | Difficulty: ${question.dynamicDifficulty || question.difficulty}`;
            
            // Clear options container
            optionsContainer.innerHTML = '';
            
            // Add options
            question.options.forEach((option, index) => {
                const buttonElement = document.createElement('button');
                buttonElement.className = 'option-btn';
                buttonElement.textContent = option;
                buttonElement.dataset.index = index;
                
                buttonElement.addEventListener('click', function() {
                    // Remove selected class from all options
                    document.querySelectorAll('.option-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked option
                    this.classList.add('selected');
                    
                    // Enable submit button
                    submitButton.disabled = false;
                    
                    // Store selected answer
                    simulator.selectedAnswer = parseInt(this.dataset.index);
                });
                
                optionsContainer.appendChild(buttonElement);
            });
            
            // Add hint button for hard questions
            if ((question.dynamicDifficulty || question.difficulty) === 'Hard') {
                const hintButton = document.createElement('button');
                hintButton.className = 'btn btn-secondary';
                hintButton.textContent = 'Get Hint';
                hintButton.style.marginTop = '15px';
                
                hintButton.addEventListener('click', function() {
                    // Generate a simple hint based on the correct answer
                    const correctOption = question.options[question.correctAnswer];
                    let hint = '';
                    
                    if (question.hint) {
                        hint = question.hint;
                    } else {
                        // Generate a simple hint
                        hint = `Think about the key characteristics of ${correctOption.split(' ').slice(-2).join(' ')}...`;
                    }
                    
                    const hintElement = document.createElement('div');
                    hintElement.className = 'hint-text';
                    hintElement.style.marginTop = '10px';
                    hintElement.style.padding = '10px';
                    hintElement.style.backgroundColor = 'var(--primary-light)';
                    hintElement.style.borderRadius = '4px';
                    hintElement.style.fontStyle = 'italic';
                    hintElement.textContent = hint;
                    
                    // Remove any existing hint
                    const existingHint = optionsContainer.querySelector('.hint-text');
                    if (existingHint) {
                        existingHint.remove();
                    }
                    
                    // Add the hint
                    optionsContainer.appendChild(hintElement);
                    
                    // Disable the hint button after use
                    this.disabled = true;
                });
                
                optionsContainer.appendChild(hintButton);
            }
        }

        // Set up event listeners for question interface
        function setupQuestionEventListeners() {
            const submitButton = document.getElementById('submitAnswerBtn');
            const nextButton = document.getElementById('nextQuestionBtn');
            const randomQuestionBtn = document.getElementById('randomQuestionBtn');
            
            // Submit answer button
            submitButton.addEventListener('click', function() {
                const question = simulator.currentQuestion;
                const selectedAnswer = simulator.selectedAnswer;
                
                if (selectedAnswer === null) return;
                
                const isCorrect = selectedAnswer === question.correctAnswer;
                
                // Update the UI to show correct/incorrect
                const optionButtons = document.querySelectorAll('.option-btn');
                optionButtons.forEach((btn, index) => {
                    if (index === question.correctAnswer) {
                        btn.classList.add('correct');
                    } else if (index === selectedAnswer && !isCorrect) {
                        btn.classList.add('incorrect');
                    }
                });
                
                // Show explanation
                const explanation = document.getElementById('explanation');
                explanation.innerHTML = `<h4>${isCorrect ? 'Correct!' : 'Incorrect!'}</h4><div>${question.explanation}</div>`;
                explanation.classList.remove('hidden');
                
                // Hide submit button, show next button
                this.classList.add('hidden');
                document.getElementById('nextQuestionBtn').classList.remove('hidden');
                
                // Mark question as answered in stats
                simulator.markQuestionAsAnswered(question.id, selectedAnswer, isCorrect);
            });
            
            // Next question button
            nextButton.addEventListener('click', function() {
                // Get current category and difficulty
                const activeCategory = document.querySelector('#categoryButtons .btn.active')?.textContent || 'All';
                const activeDifficulty = document.querySelector('.difficulty-btn.active')?.dataset.difficulty || 'All';
                
                // Display a new random question
                displayRandomQuestion(activeCategory, activeDifficulty);
            });
            
            // Random question button
            randomQuestionBtn.addEventListener('click', function() {
                // Get current difficulty
                const activeDifficulty = document.querySelector('.difficulty-btn.active')?.dataset.difficulty || 'All';
                
                // Display a random question from any category
                displayRandomQuestion('All', activeDifficulty);
            });
        }

        // Setup exam related event listeners and functionality
        function setupExamEventListeners() {
            const startExamBtn = document.getElementById('startExamBtn');
            const examLength = document.getElementById('examLength');
            const prevExamQuestionBtn = document.getElementById('prevExamQuestionBtn');
            const nextExamQuestionBtn = document.getElementById('nextExamQuestionBtn');
            const finishExamBtn = document.getElementById('finishExamBtn');
            const reviewExamBtn = document.getElementById('reviewExamBtn');
            const newExamBtn = document.getElementById('newExamBtn');
            
            // Start exam button
            startExamBtn.addEventListener('click', function() {
                const questionCount = parseInt(examLength.value);
                
                // Generate exam questions
                const success = simulator.generateExam(questionCount);
                
                if (!success) {
                    const notification = document.createElement('div');
                    notification.className = 'notification error';
                    notification.innerHTML = `<p>Not enough questions available. Using all ${simulator.examQuestions.length} available questions.</p>`;
                    document.body.appendChild(notification);
                    
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 4000);
                }
                
                // Hide exam setup, show exam content
                document.getElementById('examSetup').classList.add('hidden');
                document.getElementById('examContent').classList.remove('hidden');
                
                // Set up exam navigation
                setupExamNavigation();
                
                // Display first question
                displayExamQuestion(0);
                
                // Start timer
                startExamTimer();
            });
            
            // Exam navigation buttons
            prevExamQuestionBtn.addEventListener('click', function() {
                if (simulator.currentExamQuestionIndex > 0) {
                    displayExamQuestion(simulator.currentExamQuestionIndex - 1);
                }
            });
            
            nextExamQuestionBtn.addEventListener('click', function() {
                if (simulator.currentExamQuestionIndex < simulator.examQuestions.length - 1) {
                    displayExamQuestion(simulator.currentExamQuestionIndex + 1);
                }
            });
            
            // Finish exam button
            finishExamBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to finish this exam? You cannot return to it after viewing results.')) {
                    // Calculate results
                    const results = simulator.calculateExamResults();
                    
                    // Hide exam content, show results
                    document.getElementById('examContent').classList.add('hidden');
                    document.getElementById('examResults').classList.remove('hidden');
                    
                    // Stop timer
                    stopExamTimer();
                    
                    // Display results
                    document.getElementById('examScore').textContent = results.correct;
                    document.getElementById('examTotal').textContent = results.total;
                    document.getElementById('examPercentage').textContent = results.percentage + '%';
                    document.getElementById('examTimeSpent').textContent = results.timeSpent;
                    document.getElementById('examCorrect').textContent = results.correct;
                    document.getElementById('examIncorrect').textContent = results.total - results.correct;
                    
                    // Display incorrect answers
                    displayIncorrectAnswers();
                }
            });
            
            // Review exam button
            reviewExamBtn.addEventListener('click', function() {
                // Implementation for reviewing all exam questions with answers
                reviewAllExamQuestions();
            });
            
            // New exam button
            newExamBtn.addEventListener('click', function() {
                // Reset exam UI
                document.getElementById('examResults').classList.add('hidden');
                document.getElementById('examSetup').classList.remove('hidden');
                
                // Clear exam questions and answers
                simulator.examQuestions = [];
                simulator.examAnswers = [];
            });
        }

        // Set up exam navigation
        function setupExamNavigation() {
            const navigation = document.getElementById('questionNavigation');
            navigation.innerHTML = '';
            
            for (let i = 0; i < simulator.examQuestions.length; i++) {
                const button = document.createElement('button');
                button.className = 'question-nav-btn';
                button.textContent = i + 1;
                button.setAttribute('aria-label', `Go to question ${i + 1}`);
                
                button.addEventListener('click', function() {
                    displayExamQuestion(i);
                });
                
                navigation.appendChild(button);
            }
            
            // Update progress text
            const progressText = document.getElementById('examProgress');
            progressText.textContent = `0/${simulator.examQuestions.length}`;
            
            // Update progress bar
            const progressBar = document.getElementById('examProgressBar');
            progressBar.style.width = '0%';
        }

        // Display current exam question
        function displayExamQuestion(index) {
            simulator.currentExamQuestionIndex = index;
            
            const question = simulator.examQuestions[index];
            const examQuestionText = document.getElementById('examQuestionText');
            const examQuestionCategory = document.getElementById('examQuestionCategory');
            const examOptionsContainer = document.getElementById('examOptionsContainer');
            
            // Set question text and category
            examQuestionText.textContent = question.question;
            examQuestionCategory.textContent = `Category: ${question.category}`;
            
            // Clear options container
            examOptionsContainer.innerHTML = '';
            
            // Add options
            question.options.forEach((option, optionIndex) => {
                const buttonElement = document.createElement('button');
                buttonElement.className = 'option-btn';
                buttonElement.textContent = option;
                buttonElement.dataset.index = optionIndex;
                
                // If this option was previously selected, mark it
                if (simulator.examAnswers[index] === optionIndex) {
                    buttonElement.classList.add('selected');
                }
                
                buttonElement.addEventListener('click', function() {
                    // Remove selected class from all options
                    document.querySelectorAll('#examOptionsContainer .option-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked option
                    this.classList.add('selected');
                    
                    // Store selected answer
                    simulator.examAnswers[index] = parseInt(this.dataset.index);
                    
                    // Mark this question as answered in navigation
                    document.querySelectorAll('.question-nav-btn')[index].classList.add('answered');
                    
                    // Update progress
                    updateExamProgress();
                });
                
                examOptionsContainer.appendChild(buttonElement);
            });
            
            // Update navigation
            const navButtons = document.querySelectorAll('.question-nav-btn');
            navButtons.forEach(btn => btn.classList.remove('current'));
            navButtons[index].classList.add('current');
            
            // Update prev/next buttons
            document.getElementById('prevExamQuestionBtn').disabled = index === 0;
            document.getElementById('nextExamQuestionBtn').disabled = index === simulator.examQuestions.length - 1;
        }

        // Update exam progress
        function updateExamProgress() {
            // Count answered questions
            const answeredCount = simulator.examAnswers.filter(answer => answer !== null).length;
            
            // Update progress text
            const progressText = document.getElementById('examProgress');
            progressText.textContent = `${answeredCount}/${simulator.examQuestions.length}`;
            
            // Update progress bar
            const progressBar = document.getElementById('examProgressBar');
            const percentage = Math.round((answeredCount / simulator.examQuestions.length) * 100);
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);
        }

        // Exam timer variables
        let examTimerInterval;
        let examSeconds = 0;

        // Start exam timer
        function startExamTimer() {
            examSeconds = 0;
            const timerElement = document.getElementById('examTimer');
            
            examTimerInterval = setInterval(() => {
                examSeconds++;
                const hours = Math.floor(examSeconds / 3600);
                const minutes = Math.floor((examSeconds % 3600) / 60);
                const seconds = examSeconds % 60;
                
                timerElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // Stop exam timer
        function stopExamTimer() {
            clearInterval(examTimerInterval);
        }

        // Display incorrect answers in review section
        function displayIncorrectAnswers() {
            const container = document.getElementById('incorrectAnswersContainer');
            container.innerHTML = '<h3>Incorrect Answers</h3>';
            
            let hasIncorrect = false;
            
            for (let i = 0; i < simulator.examQuestions.length; i++) {
                const question = simulator.examQuestions[i];
                const selectedAnswer = simulator.examAnswers[i];
                
                if (selectedAnswer !== null && selectedAnswer !== question.correctAnswer) {
                    hasIncorrect = true;
                    
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'anki-card';
                    
                    const questionText = document.createElement('div');
                    questionText.className = 'anki-question';
                    questionText.textContent = `Question ${i + 1}: ${question.question}`;
                    
                    const yourAnswer = document.createElement('div');
                    yourAnswer.innerHTML = `<strong>Your answer:</strong> ${question.options[selectedAnswer]} <span style="color: var(--error)">(Incorrect)</span>`;
                    
                    const correctAnswer = document.createElement('div');
                    correctAnswer.innerHTML = `<strong>Correct answer:</strong> ${question.options[question.correctAnswer]}`;
                    
                    const explanation = document.createElement('div');
                    explanation.className = 'anki-answer';
                    explanation.innerHTML = `<strong>Explanation:</strong> ${question.explanation}`;
                    
                    questionDiv.appendChild(questionText);
                    questionDiv.appendChild(yourAnswer);
                    questionDiv.appendChild(correctAnswer);
                    questionDiv.appendChild(explanation);
                    
                    container.appendChild(questionDiv);
                }
            }
            
            if (!hasIncorrect) {
                container.innerHTML += '<p>Congratulations! You got all questions correct.</p>';
            }
        }

        // Function to review all exam questions with answers
        function reviewAllExamQuestions() {
            const container = document.getElementById('incorrectAnswersContainer');
            container.innerHTML = '<h3>Complete Exam Review</h3>';
            
            for (let i = 0; i < simulator.examQuestions.length; i++) {
                const question = simulator.examQuestions[i];
                const selectedAnswer = simulator.examAnswers[i];
                const isCorrect = selectedAnswer === question.correctAnswer;
                
                const questionDiv = document.createElement('div');
                questionDiv.className = 'anki-card';
                
                const questionHeader = document.createElement('div');
                questionHeader.className = 'anki-question';
                questionHeader.textContent = `Question ${i + 1}: ${question.question}`;
                
                const yourAnswer = document.createElement('div');
                yourAnswer.innerHTML = `<strong>Your answer:</strong> ${selectedAnswer !== null ? question.options[selectedAnswer] : 'Not answered'} 
                               <span style="color: ${isCorrect ? 'var(--success)' : 'var(--error)'}">
                                  (${isCorrect ? 'Correct' : 'Incorrect'})
                               </span>`;
                
                const correctAnswer = document.createElement('div');
                correctAnswer.innerHTML = `<strong>Correct answer:</strong> ${question.options[question.correctAnswer]}`;
                
                const explanation = document.createElement('div');
                explanation.className = 'anki-answer';
                explanation.innerHTML = `<strong>Explanation:</strong> ${question.explanation}`;
                
                questionDiv.appendChild(questionHeader);
                questionDiv.appendChild(yourAnswer);
                
                if (!isCorrect) {
                    questionDiv.appendChild(correctAnswer);
                }
                
                questionDiv.appendChild(explanation);
                container.appendChild(questionDiv);
            }
        }

        // Add sample questions data
        const sampleQuestions = [
            {
                id: 'sample_1',
                question: 'Which of the following is NOT a characteristic of central retinal artery occlusion (CRAO)?',
                options: [
                    'Retinal whitening',
                    'Cherry-red spot',
                    'Box-car segmentation of blood columns',
                    'Retinal hemorrhages'
                ],
                correctAnswer: 3,
                explanation: 'Retinal hemorrhages are not typically seen in CRAO. They are more characteristic of central retinal vein occlusion (CRVO). CRAO typically presents with retinal whitening due to ischemia, a cherry-red spot at the fovea, and box-car segmentation of blood columns in retinal vessels.',
                category: 'Posterior Segment',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_2',
                question: 'Which of the following drugs is LEAST likely to cause anterior uveitis?',
                options: [
                    'Rifabutin',
                    'Cidofovir',
                    'Latanoprost',
                    'Ciprofloxacin'
                ],
                correctAnswer: 3,
                explanation: 'Ciprofloxacin is least likely to cause anterior uveitis among the options listed. Rifabutin (used in mycobacterial infections), cidofovir (antiviral), and latanoprost (prostaglandin analog used for glaucoma) are all known to potentially cause anterior uveitis as a side effect.',
                category: 'Anterior Segment',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_3',
                question: 'In a patient with acute angle-closure glaucoma, which of the following medications would be contraindicated?',
                options: [
                    'Timolol',
                    'Atropine',
                    'Acetazolamide',
                    'Pilocarpine'
                ],
                correctAnswer: 1,
                explanation: 'Atropine is contraindicated in acute angle-closure glaucoma because it is a mydriatic (pupil-dilating) agent that can worsen angle closure. Timolol (beta-blocker), acetazolamide (carbonic anhydrase inhibitor), and pilocarpine (miotic) are all used in the management of acute angle-closure glaucoma.',
                category: 'Glaucoma',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_4',
                question: 'Which cranial nerve palsy is most commonly associated with diabetes mellitus?',
                options: [
                    'Third nerve palsy',
                    'Fourth nerve palsy',
                    'Sixth nerve palsy',
                    'Seventh nerve palsy'
                ],
                correctAnswer: 2,
                explanation: 'Sixth nerve (abducens) palsy is the most common cranial nerve palsy associated with diabetes mellitus. It causes lateral rectus muscle weakness resulting in horizontal diplopia that worsens on looking toward the affected side.',
                category: 'Neuro-ophthalmology',
                difficulty: 'Easy',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_5',
                question: 'Which of the following is the most common cause of childhood blindness worldwide?',
                options: [
                    'Congenital cataract',
                    'Vitamin A deficiency',
                    'Retinopathy of prematurity',
                    'Congenital glaucoma'
                ],
                correctAnswer: 1,
                explanation: 'Vitamin A deficiency is the most common cause of childhood blindness worldwide, particularly in developing countries. It leads to xerophthalmia, keratomalacia, and eventual blindness if untreated.',
                category: 'Pediatric Ophthalmology',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_6',
                question: 'Which of the following BEST describes the histopathology of chalazion?',
                options: [
                    'Acute inflammatory reaction',
                    'Granulomatous inflammatory reaction',
                    'Sebaceous cell carcinoma',
                    'Squamous cell papilloma'
                ],
                correctAnswer: 1,
                explanation: 'A chalazion is characterized by a granulomatous inflammatory reaction to retained sebaceous secretions. It occurs when a meibomian gland becomes obstructed, leading to lipid material release into the surrounding tissues and subsequent granulomatous inflammation.',
                category: 'Oculoplastics',
                difficulty: 'Easy',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_7',
                question: 'What is the most common cause of infectious keratitis in contact lens wearers?',
                options: [
                    'Staphylococcus aureus',
                    'Streptococcus pneumoniae',
                    'Pseudomonas aeruginosa',
                    'Herpes simplex virus'
                ],
                correctAnswer: 2,
                explanation: 'Pseudomonas aeruginosa is the most common cause of infectious keratitis in contact lens wearers. It can cause a rapidly progressive, suppurative corneal infection with stromal necrosis. Contact lens wear, especially extended wear or poor hygiene, is a major risk factor.',
                category: 'Anterior Segment',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_8',
                question: 'Which of the following findings is NOT typically seen in ocular cicatricial pemphigoid?',
                options: [
                    'Symblepharon',
                    'Entropion',
                    'Trichiasis',
                    'Open-angle glaucoma'
                ],
                correctAnswer: 3,
                explanation: 'Open-angle glaucoma is not typically associated with ocular cicatricial pemphigoid (OCP). OCP is an autoimmune disease that affects mucous membranes and causes progressive scarring of the conjunctiva, leading to symblepharon (adhesions between the bulbar and palpebral conjunctiva), entropion (inward turning of the eyelid), and trichiasis (misdirected eyelashes).',
                category: 'Anterior Segment',
                difficulty: 'Hard',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_9',
                question: 'Which drug used in the treatment of glaucoma works by increasing uveoscleral outflow?',
                options: [
                    'Timolol',
                    'Brimonidine',
                    'Latanoprost',
                    'Dorzolamide'
                ],
                correctAnswer: 2,
                explanation: 'Latanoprost, a prostaglandin analog, works primarily by increasing uveoscleral outflow. Timolol (beta-blocker) decreases aqueous humor production, brimonidine (alpha-2 agonist) decreases aqueous production and may increase uveoscleral outflow to a lesser extent, and dorzolamide (carbonic anhydrase inhibitor) decreases aqueous humor production.',
                category: 'Glaucoma',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_10',
                question: 'What is the most common cause of infectious endophthalmitis following cataract surgery?',
                options: [
                    'Staphylococcus epidermidis',
                    'Pseudomonas aeruginosa',
                    'Candida albicans',
                    'Streptococcus pneumoniae'
                ],
                correctAnswer: 0,
                explanation: 'Staphylococcus epidermidis (coagulase-negative staphylococci) is the most common cause of infectious endophthalmitis following cataract surgery. It is part of the normal flora of the eyelid and conjunctiva and can enter the eye during surgery.',
                category: 'Anterior Segment',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            }
        ];

        // Add additional sample questions
        const additionalSampleQuestions = [
            {
                id: 'sample_11',
                question: 'Which of the following is a common cause of rubeosis iridis?',
                options: [
                    'Chronic anterior uveitis',
                    'Central retinal artery occlusion',
                    'Central retinal vein occlusion',
                    'Posterior vitreous detachment'
                ],
                correctAnswer: 2,
                explanation: 'Central retinal vein occlusion (CRVO) is a common cause of rubeosis iridis due to retinal ischemia leading to production of vascular endothelial growth factor (VEGF), which promotes neovascularization.',
                category: 'Posterior Segment',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_12',
                question: 'Which of the following conditions is associated with transient visual obscurations?',
                options: [
                    'Open-angle glaucoma',
                    'Papilledema',
                    'Age-related macular degeneration',
                    'Diabetic retinopathy'
                ],
                correctAnswer: 1,
                explanation: 'Transient visual obscurations (TVOs) are brief episodes of vision loss lasting seconds, often precipitated by changes in posture. They are a classic symptom of papilledema due to increased intracranial pressure.',
                category: 'Neuro-ophthalmology',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_13',
                question: 'What is the most likely diagnosis for a 55-year-old patient presenting with bilateral ptosis, ophthalmoplegia, and proximal muscle weakness that worsens throughout the day?',
                options: [
                    'Myasthenia gravis',
                    'Multiple sclerosis',
                    'Thyroid eye disease',
                    'Third nerve palsy'
                ],
                correctAnswer: 0,
                explanation: 'Myasthenia gravis is an autoimmune disorder characterized by fatigable muscle weakness that typically worsens throughout the day. Ocular symptoms like ptosis and ophthalmoplegia are common presenting features, often preceding generalized weakness.',
                category: 'Neuro-ophthalmology',
                difficulty: 'Easy',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_14',
                question: 'In the management of nasolacrimal duct obstruction in adults, which procedure has the highest success rate?',
                options: [
                    'Probing and irrigation',
                    'Balloon dacryoplasty',
                    'Silicone intubation',
                    'External dacryocystorhinostomy (DCR)'
                ],
                correctAnswer: 3,
                explanation: 'External dacryocystorhinostomy (DCR) has the highest success rate (approximately 90-95%) for treating nasolacrimal duct obstruction in adults. It involves creating a direct communication between the lacrimal sac and nasal cavity, bypassing the obstructed nasolacrimal duct.',
                category: 'Oculoplastics',
                difficulty: 'Medium',
                source: 'Sample',
                stats: { attempts: 0, correct: 0 }
            },
            {
                id: 'sample_15',
                question: 'Which diagnostic test is most useful for distinguishing papilledema from pseudopapilledema?',
                options: [
                    'Visual field testing',
                    'Optical coherence tomography (OCT)',
                    'Fluorescein angiography',
                    'B-scan ultrasonography'
                ],
                correctAnswer: 3,
                explanation: 'B-scan ultrasonography is most useful for distinguishing true papilledema from pseudopapilledema. In pseudopapilledema due to optic disc drusen, B-scan can detect calcifications within the optic nerve head, which are highly reflective and appear as bright spots. True papilledema will show widening of the optic nerve sheath diameter without calcifications.',
                category: 'Neuro-ophthalmology',
                difficulty: 'Hard',
                source: 'Sample',
                hint: 'Think about which imaging modality can detect calcifications within the optic nerve head.',
                stats: { attempts: 0, correct: 0 }
            }
        ];

        // Function to initialize database with sample questions if empty
        function initializeDatabaseIfEmpty() {
            if (simulator.questionDatabase.length === 0) {
                simulator.questionDatabase = [...sampleQuestions, ...additionalSampleQuestions];
                localStorage.setItem('ophthQA_database', JSON.stringify(simulator.questionDatabase));
                console.log('Database initialized with sample questions');
            }
        }

        // Function to initialize source selector
        function initializeSourceSelector() {
            const sourceSelector = document.getElementById('sourceSelector');
            if (!sourceSelector) return;
            
            // Clear existing content
            sourceSelector.innerHTML = '';
            
            // Add sources
            const sources = [
                {id: 'sample', name: 'Sample Questions'},
                {id: 'user', name: 'Your Imported Questions'},
                {id: 'external', name: 'External Sources'}
            ];
            
            sources.forEach(source => {
                const sourceOption = document.createElement('div');
                sourceOption.className = 'source-option';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `source-${source.id}`;
                
                // Check if the source is active - default to true if not set
                checkbox.checked = simulator.activeExternalSources 
                    ? (simulator.activeExternalSources[source.id] !== false) 
                    : true;
                    
                checkbox.addEventListener('change', updateActiveSources);
                
                const label = document.createElement('label');
                label.htmlFor = `source-${source.id}`;
                label.textContent = source.name;
                
                sourceOption.appendChild(checkbox);
                sourceOption.appendChild(label);
                sourceSelector.appendChild(sourceOption);
            });
            
            // Initialize API key inputs
            initializeApiKeyInputs();
            
            // Initialize activeExternalSources if it's empty
            if (!simulator.activeExternalSources || Object.keys(simulator.activeExternalSources).length === 0) {
                updateActiveSources();
            }
        }

        // Function to initialize API key inputs
        function initializeApiKeyInputs() {
            const apiKeyInputs = document.getElementById('apiKeyInputs');
            if (!apiKeyInputs) return;
            
            // Clear existing content
            apiKeyInputs.innerHTML = '';
            
            // Define available API sources
            const apiSources = [
                { id: 'ophthalmoQA', name: 'OphtalmoQA API', description: 'Access to premium ophthalmology question bank' },
                { id: 'eyeExams', name: 'Eye Exams API', description: 'Clinical case simulations and image-based questions' }
            ];
            
            apiSources.forEach(source => {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                
                const label = document.createElement('label');
                label.htmlFor = `api-key-${source.id}`;
                label.innerHTML = `${source.name} <div class="info-tooltip"><span class="info-icon">i</span><span class="tooltip-text">${source.description}</span></div>`;
                
                const input = document.createElement('input');
                input.type = 'password';
                input.id = `api-key-${source.id}`;
                input.placeholder = `Enter ${source.name} Key`;
                input.value = simulator.apiKeys[source.id] || '';
                input.autocomplete = 'off';
                
                // Add save handler
                input.addEventListener('change', function() {
                    saveApiKey(source.id, this.value.trim());
                });
                
                inputGroup.appendChild(label);
                inputGroup.appendChild(input);
                apiKeyInputs.appendChild(inputGroup);
            });
            
            // Add a "Test API Keys" button
            const testButton = document.createElement('button');
            testButton.className = 'btn btn-secondary';
            testButton.textContent = 'Test API Keys';
            testButton.addEventListener('click', testApiKeys);
            
            apiKeyInputs.appendChild(testButton);
        }

        // Function to save API key
        function saveApiKey(sourceId, key) {
            // Don't save empty keys
            if (!key) {
                delete simulator.apiKeys[sourceId];
            } else {
                simulator.apiKeys[sourceId] = key;
            }
            
            // Save to localStorage
            localStorage.setItem('ophthQA_apiKeys', JSON.stringify(simulator.apiKeys));
            
            // Show notification
            showNotification('API key saved successfully', 'success');
        }

        // Function to test API keys
        async function testApiKeys() {
            // Show loading notification
            const notification = showNotification('Testing API keys...', 'info');
            notification.classList.add('loading');
            
            try {
                // For each API key, attempt to validate
                const keys = Object.keys(simulator.apiKeys);
                
                if (keys.length === 0) {
                    throw new Error('No API keys to test');
                }
                
                let successCount = 0;
                
                for (const sourceId of keys) {
                    const key = simulator.apiKeys[sourceId];
                    
                    // In a real implementation, you would make an actual API request here
                    // For this demo, we'll simulate an API call with a timeout
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Simulate validation (would be replaced by actual API validation)
                    if (key && key.length > 5) {
                        successCount++;
                    }
                }
                
                if (successCount === keys.length) {
                    showNotification(`All API keys validated successfully`, 'success');
                } else {
                    showNotification(`${successCount} of ${keys.length} API keys validated`, 'info');
                }
            } catch (error) {
                showNotification(`Failed to test API keys: ${error.message}`, 'error');
            } finally {
                // Remove the loading notification
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }
        }

        // Function to update active sources
        function updateActiveSources() {
            const activeSourcesObj = {};
            
            // Get all checked source checkboxes
            document.querySelectorAll('#sourceSelector input[type="checkbox"]:checked').forEach(checkbox => {
                const sourceId = checkbox.id.replace('source-', '');
                activeSourcesObj[sourceId] = true;
            });
            
            // Save to simulator and localStorage
            simulator.activeExternalSources = activeSourcesObj;
            localStorage.setItem('ophthQA_activeSources', JSON.stringify(activeSourcesObj));
            
            // Show confirmation
            showNotification('Source filters updated', 'success');
        }

        // Add mobile optimization script
        function optimizeForMobile() {
            if (window.innerWidth < 768) {
                // Adjust button sizes for touch
                document.querySelectorAll('.btn, .option-btn').forEach(btn => {
                    btn.style.minHeight = '44px';
                    btn.style.padding = '12px 15px';
                });
                
                // Adjust option buttons to be more touch-friendly
                document.querySelectorAll('.option-btn').forEach(btn => {
                    btn.style.fontSize = '16px';
                    btn.style.marginBottom = '12px';
                });
                
                // Adjust navigation in exam mode
                document.querySelectorAll('.question-nav-btn').forEach(btn => {
                    btn.style.width = '36px';
                    btn.style.height = '36px';
                });
                
                // Make tab buttons scrollable
                const tabButtons = document.querySelector('.tab-buttons');
                if (tabButtons) {
                    tabButtons.style.overflow = 'auto';
                    tabButtons.style.whiteSpace = 'nowrap';
                    tabButtons.style.display = 'block';
                    
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        btn.style.display = 'inline-block';
                        btn.style.minWidth = '110px';
                    });
                }
            }
        }

        // Call optimizeForMobile on window resize
        window.addEventListener('resize', debounce(optimizeForMobile, 250));

        // Add to DOMContentLoaded event
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Optimize for mobile
            optimizeForMobile();
            
            // Initialize smooth scrolling for tab changes
            tabButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Scroll to top of tab content
                    document.querySelector('.tab-content').scrollIntoView({ behavior: 'smooth' });
                });
            });
        });

        // Add debounce function if not already defined
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        // Function to update the stats tab regularly
        function scheduleStatsUpdate() {
            // Update stats if on the stats tab
            if (document.getElementById('stats').classList.contains('active')) {
                updateStatsDisplay();
            }
            
            // Schedule next update
            setTimeout(scheduleStatsUpdate, 60000); // Update every minute
        }

        // Start scheduled stats update
        document.addEventListener('DOMContentLoaded', function() {
            scheduleStatsUpdate();
        });

        // Add to DOMContentLoaded event
        document.addEventListener('DOMContentLoaded', function() {
            // Load activity log
            simulator.loadActivity();
            
            // Rest of the code...
        });

        // Add function to recover from local storage corruption
        function recoverFromStorageCorruption() {
            try {
                // Check if localStorage is accessible
                const testItem = 'ophthQA_test_' + Date.now();
                localStorage.setItem(testItem, 'test');
                localStorage.removeItem(testItem);
                
                // Try to parse stored data
                let hasCorruption = false;
                
                try {
                    const savedStats = localStorage.getItem('ophthQA_stats');
                    if (savedStats) JSON.parse(savedStats);
                } catch (e) {
                    console.warn('Stats data corruption detected');
                    localStorage.removeItem('ophthQA_stats');
                    hasCorruption = true;
                }
                
                try {
                    const savedCategoryStats = localStorage.getItem('ophthQA_categoryStats');
                    if (savedCategoryStats) JSON.parse(savedCategoryStats);
                } catch (e) {
                    console.warn('Category stats data corruption detected');
                    localStorage.removeItem('ophthQA_categoryStats');
                    hasCorruption = true;
                }
                
                try {
                    const savedDatabase = localStorage.getItem('ophthQA_database');
                    if (savedDatabase) JSON.parse(savedDatabase);
                } catch (e) {
                    console.warn('Database corruption detected');
                    localStorage.removeItem('ophthQA_database');
                    hasCorruption = true;
                }
                
                try {
                    const savedApiKeys = localStorage.getItem('ophthQA_apiKeys');
                    if (savedApiKeys) JSON.parse(savedApiKeys);
                } catch (e) {
                    console.warn('API keys data corruption detected');
                    localStorage.removeItem('ophthQA_apiKeys');
                    hasCorruption = true;
                }
                
                try {
                    const savedExternalSources = localStorage.getItem('ophthQA_activeSources');
                    if (savedExternalSources) JSON.parse(savedExternalSources);
                } catch (e) {
                    console.warn('External sources data corruption detected');
                    localStorage.removeItem('ophthQA_activeSources');
                    hasCorruption = true;
                }
                
                try {
                    const savedActivity = localStorage.getItem('ophthQA_activityLog');
                    if (savedActivity) JSON.parse(savedActivity);
                } catch (e) {
                    console.warn('Activity log data corruption detected');
                    localStorage.removeItem('ophthQA_activityLog');
                    hasCorruption = true;
                }
                
                if (hasCorruption) {
                    showNotification('Some data was corrupted and has been reset. Your application has been recovered.', 'info');
                }
                
                return true;
            } catch (e) {
                console.error('Fatal storage error:', e);
                
                // Show error to user
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'fixed';
                errorDiv.style.top = '0';
                errorDiv.style.left = '0';
                errorDiv.style.right = '0';
                errorDiv.style.backgroundColor = '#f44336';
                errorDiv.style.color = 'white';
                errorDiv.style.padding = '15px';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '9999';
                errorDiv.innerHTML = `
                    <p><strong>Storage Error:</strong> Unable to access local storage. This could be due to private browsing mode, storage restrictions, or browser settings.</p>
                    <p>The application will run in memory-only mode. Your data will not be saved.</p>
                    <button id="dismiss-error" style="background: white; color: #f44336; border: none; padding: 5px 10px; margin-top: 10px; cursor: pointer;">Dismiss</button>
                `;
                
                document.body.appendChild(errorDiv);
                
                document.getElementById('dismiss-error').addEventListener('click', function() {
                    errorDiv.style.display = 'none';
                });
                
                // Setup fallback in-memory storage
                setupMemoryOnlyMode();
                
                return false;
            }
        }

        // Function to set up memory-only mode when localStorage is unavailable
        function setupMemoryOnlyMode() {
            // Create in-memory storage
            const memoryStorage = {};
            
            // Override localStorage methods
            localStorage.getItem = function(key) {
                return memoryStorage[key] || null;
            };
            
            localStorage.setItem = function(key, value) {
                memoryStorage[key] = value;
            };
            
            localStorage.removeItem = function(key) {
                delete memoryStorage[key];
            };
            
            localStorage.clear = function() {
                for (const key in memoryStorage) {
                    delete memoryStorage[key];
                }
            };
            
            // Initialize simulator with default data
            simulator.questionDatabase = [...sampleQuestions, ...additionalSampleQuestions];
            simulator.stats = {
                totalQuestions: 0,
                correctAnswers: 0,
                examsCompleted: 0
            };
            simulator.categoryStats = {};
            simulator.apiKeys = {};
            simulator.activeExternalSources = {};
            simulator.activityLog = [];
            
            console.log('Running in memory-only mode');
        }

        // Update the DOMContentLoaded event to include recovery
        document.addEventListener('DOMContentLoaded', () => {
            // Check storage and recover if necessary
            const storageOk = recoverFromStorageCorruption();
            
            // Load saved data
            simulator.loadStats();
            
            // Initialize database with sample questions if empty
            initializeDatabaseIfEmpty();
            
            // Fix home page layout
            improveHomePageLayout();
            
            // Initialize tabs correctly
            initializeTabs();
            
            // Load saved appearance settings
            loadAppearanceSettings();
            
            // Initialize category buttons
            refreshCategoryButtons();
            
            // Initialize difficulty buttons
            initializeDifficultyButtons();
            
            // Set up event listeners for question interface
            setupQuestionEventListeners();
            
            // Set up event listeners for exam interface
            setupExamEventListeners();
            
            // Initialize source selector
            initializeSourceSelector();
            
            // Load activity log
            simulator.loadActivity();
            
            // If running in a browser that doesn't support localStorage well (like some Safari versions)
            if (!storageOk) {
                showNotification('Running in memory-only mode. Your data will not be saved between sessions.', 'warning', 10000);
            }
        });
    </script>
</body>
</html>
